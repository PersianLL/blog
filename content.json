{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://persian.gitee.io/blog","root":"/blog/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-03-03T13:44:07.103Z","updated":"2021-03-03T04:43:19.831Z","comments":false,"path":"/404.html","permalink":"http://persian.gitee.io/blog/404.html","excerpt":"","text":""},{"title":"卢绪亮 de 简历","date":"2021-03-04T15:09:57.270Z","updated":"2021-03-04T15:09:57.270Z","comments":false,"path":"about/index.html","permalink":"http://persian.gitee.io/blog/about/index.html","excerpt":"","text":"电话：15966676035 邮箱：&#x31;&#48;&#x37;&#x34;&#x31;&#x35;&#x38;&#54;&#x36;&#57;&#64;&#113;&#x71;&#46;&#x63;&#111;&#x6d; 地址：杭州市滨江区 微信：L15966676035 学历：本科 工作经验：2017-03 至今 求职意向：Java 研发岗 期望薪资：面议 自我描述 ① 能力可靠，有责任心，有大局观，入职后很快得到直属领导的信赖，进而成长为某个子产品的组长，并持续到离职；② 学习能力强，对新事物的接受力较好，可以很快的适应工作环境，进入工作状态；③ 有过企业服务号（基于微信公众号平台）的开发经验；④ 优势：擅长全栈开发，对前后端技术均能熟练使用；缺点：技术深度达不到专业做后端或做前端的水平，但是个人学习热情高涨，一直在进步的路上。 技能 IDE： idea、myeclipse、eclipse WEB容器： TomcatMVC框架： Struts1、Struts2、SpringMVC容器框架： SpringORM框架： iBatis、MyBatis、Hibernate 数据库： SQLserver、Oracle、Mysql、Redis前端： JQuery、LayUI、echarts、Bootstrap其他： SVN、Git、Maven、SpringBoot、Shiro、Spring-Security、freemarker、Thymeleaf、WebService、WebSocket、润乾报表、iReport、Linux部分命令（偏实施部署的一些命令） 工作经历 北京众阳软件有限公司 产品开发组长 2018.03—2019.09 公司隶属于众阳健康科技集团，一家从事医疗健康软件服务的公司，公司主营业务是大数据医疗产品。在职期间负责HRP系列产品中护理管控系统的开发以及优化，并担任开发组长。工作业绩： 将负责的产品纵向分割出不同的业务模块以及代码模块； 将梳理成体系的产品从大产品中分离出来，并开始带团队独立对其进行版本规划以及发展规划； 将分离出来的产品进行代码重构，精简冗余代码，减轻产品代码的体量； 出差去使用产品的客户现场，亲身去了解客户使用产品过程中的问题以及对原先功能定义的业务逻辑进行调整，为系统功能提供足够的理论依据以及业务逻辑支持；负责对产品的升级改革进行技术选型，使之可以更快更好的维护升级以及部署上线。 北京东华厚盾软件有限公司 Java开发工程师 2017.03—2018.03 公司隶属于东华软件下的全资子公司，该公司围绕企业风险及内部体系建设，以全面预算为主线，以多维表格、流程引擎、规则引擎、大数据处理、多维分析、BI、移动应用等信息技术为工具，提供财务、业务一体化管理平台。从17年3月份开始在业务六部实习，毕业后正式入职实习部门，在职期间主要做了:① 页面样式的修改，主要是学会使用公司前端框架（EXT·JS）,完成需求任务；② 后台对于前端请求数据的逻辑增改，目的在可以熟悉SSH框架下公司给与的EIP接口，进而学会使用这些接口，使之完成页面请求数据回馈；③ 学习使用数据库Oracle，SQLserver的数据迁移，数据库之间的数据交互，针对业务需求创建合适字段的库表，并完成SSH下的库表与实体类之前的映射；④ 报表的开发制作，使用ireport，润乾报表工具进行模板开发以及后台接口逻辑程序的开发。工作业绩： 完成借款转移功能的开发，主要涉及到借款金额对预算金额的加锁以及还款金额对预算金额的解锁（线程锁的应用）； 针对系统中的财务相关的数据打印，自学ireport工具开发相应的报表以及开发报表数据源的后台逻辑； 凭证管理（凭证制作+推送凭证），使用poi是将库表数据经过需求逻辑处理生成excel，供客户端下载，使用WebService推送凭证接口等； 项目经历 HRP产品·护理管控子系统工具&amp;技能：Linux（部署环境）、Idea（编译工具）、Java8、Tomcat、Maven、（Struts1）SpringMVC+Sping+（ibatis）Mybatis、Oracle、JQuery、Echarts描述： 该系统为HRP产品的子系统，依托于众阳大数据平台，将医院的数据进行整合处理，然后产品将对医院护理部需要的数据再次整合分析并呈现给客户，目的实现护理部对全院护理业务数据统一把握，灵活的调配下属科室的护理资源的调配，提高护理工作的效率。该产品有:① 员工管理模块、② 护理质量模块、③ 护士长手册模块、④ 护理工作量模块、⑤ 护理不良事件管理、⑥ 护理敏感指标管理等。业绩：① 针对不同医院对类似功能的个性化需求，大胆的提出了功能定制的设想，并实践出了较为成熟的解决方案，这样大大的减少了需求变更频率节约了非必要的人力浪费；② 将产品进行了业务上的功能模块划分以及代码分模块（采用mvn的多模块构建）维护升级，通过这样的方式，大大降低了功能代码之间的耦合度，降低了维护成本，并且对新成员培训时，可以分模块培训，加快了新员工对工作的适应;③ 为了产品的护理质量模块的业务流程形成闭环，采取使用微信公众号平台实现消息的通知（采用springboot搭建消息中转平台，redis进行用户数据的缓存，用户关系数据的缓存）；④ 为了更快的，及时有效的将数据展示给职能部门（护理部），采用了实时电视屏的形式（echarts进行数据渲染）将业务数据进行展示，方便职能部门进行资源调配； 中能建山西院预算管理系统 工具&amp;技能：Eclipse（编译工具）、Java6、Tomcat、EXT·JS + Struts2 + Spring + Hibernate 、Oracle、SQLServer、润乾报表、iReport报表描述：该项目是公司在山西省中国能源建设公司驻场开发一个项目，该项目的前期调研，文档编写并未参与，参与了后期的项目开展+部署上线，该系统为甲方提供资金预算编制、合同管理、项目信息管理、支出类合同管理、预算执行控制、资金支付管理、预算分析等功能，使得企业可以实现支出可预算，资金流向皆控制。业绩： 承担项目的开发+部署上线，其中承担了执行控制模板的报销单打印（借款，普通报销，差旅报销等），借款管理的借款转移功能，其中包含内容：业务逻辑、设计思路、开发的代码、配置文件、执行的sql、以及权限相关、菜单等。 教育经历 山东建筑大学 全日制本科 社交主页 博客：http://persian.gitee.io/blog CSDN: https://blog.csdn.net/weixin_38001682 欢迎关注我的公众号，原创技术文章第一时间推送。"},{"title":"分类","date":"2021-03-03T13:44:07.243Z","updated":"2021-03-03T04:43:19.832Z","comments":false,"path":"categories/index.html","permalink":"http://persian.gitee.io/blog/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-03-03T13:44:07.261Z","updated":"2021-03-03T04:43:19.833Z","comments":false,"path":"tags/index.html","permalink":"http://persian.gitee.io/blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"里氏代换原则","slug":"设计原则-里氏替换原则","date":"2021-03-05T13:02:06.599Z","updated":"2021-03-05T12:09:29.522Z","comments":false,"path":"article/20210905080908.html","link":"","permalink":"http://persian.gitee.io/blog/article/20210905080908.html","excerpt":"","text":"概念 Barbara Liskov提出：标准定义：如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1代换o2时，程序P的行为没有变化，那么类型S是类型T的子类型。简单解释：所有引用基类（父类的）地方都可以用子类来替换，且程序不会有任何的异常。但是反过来就不行，所有使用子类的地方则不一定能用基类来替代。举例： 狗是动物，不能说动物是狗，因为可能还有猫。 里氏代换原则约束 子类必须实现父类的抽象方法，但不得重写（覆盖）父类的非抽象（已实现）方法; 子类中可以添加特有方法（父类中不存在),此时则无法在以父类定义的对象中使用该方法，除非在使用的时候强转基类成子类进行调用; 当子类覆盖或实现父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松; 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。 总结：所以我们在运用里氏替换原则的时候，尽量把父类设计为抽象类或者接口，让子类继承父类或者实现接口并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。里氏代换原则是开闭原则的具体实现手段之一。 示例代码1234567891011121314151617&#x2F;&#x2F; 抽象基类public abstract class Customer &#123;&#125;&#x2F;&#x2F; 子类1public class CommonCustomer extends Customer&#123;&#125;&#x2F;&#x2F; 子类2public class VIPCustomer extends Customer&#123;&#125;&#x2F;&#x2F; 逻辑在这里实现，只需要传入对应的类型即可public class ResetPassword &#123; &#x2F;&#x2F; 只需要传入Customer类即可，不管任何类型的Customer类，只要继承自Customer,都可以使用里氏替换原则进行替换，假如有新的类型，我们只需要在配置文件中注入新的类型即可。 public void resetPassword(Customer customer)&#123; &#125;&#125; 里氏替换原则是实现开闭原则不可或缺的手段之一。在本例中，通过传递参数使用基类对象，针对抽象编程，从而满足开闭原则。 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"设计原则","slug":"设计原则","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"}],"tags":[{"name":"设计原则","slug":"设计原则","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"}]},{"title":"迪米特法则","slug":"设计原则-迪米特法则（最少知道原则）","date":"2021-03-05T13:02:06.597Z","updated":"2021-03-05T12:09:29.511Z","comments":false,"path":"article/20210805080844.html","link":"","permalink":"http://persian.gitee.io/blog/article/20210805080844.html","excerpt":"","text":"欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"设计原则","slug":"设计原则","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"}],"tags":[{"name":"设计原则","slug":"设计原则","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"}]},{"title":"接口隔离原则","slug":"设计原则-接口隔离原则","date":"2021-03-05T13:02:06.596Z","updated":"2021-03-05T12:08:16.871Z","comments":false,"path":"article/20210805080815.html","link":"","permalink":"http://persian.gitee.io/blog/article/20210805080815.html","excerpt":"","text":"概念 接口隔离原则的两个定义： 使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口; 类间的依赖关系应该建立在最小的接口上; 概念含义 一个接口代表一个角色，不应该将不同的角色都交给一个接口，因为这样可能会形成一个臃肿的大接口； 特定语言的接口，表示接口仅仅是提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口。 总结：根据接口隔离原则，我们可明白，每个接口都应只承担一种相对独立的角色，不干不该干的事情。 实例 场景： 模拟动物平时的动作，当然也包括人，最初的设计就是一个总接口IAnimal，里面定义动物会有的一些动作。 12345678910111213141516171819202122232425262728293031323334353637383940public interface IAnimal&#123; &#x2F;&#x2F; 吃饭 void eat(); &#x2F;&#x2F; 工作 void work(); &#x2F;&#x2F;飞行 void fly();&#125;public class Tony implements IAnimal&#123; @Override public void eat() &#123; System.out.println(&quot;tony吃&quot;); &#125; @Override public void work() &#123; System.out.println(&quot;tony工作&quot;); &#125; @Override public void fly() &#123; System.out.println(&quot;tony不会飞&quot;); &#125;&#125;public class Bird implements IAnimal&#123; @Override public void eat() &#123; System.out.println(&quot;鸟吃&quot;); &#125; @Override public void work() &#123; System.out.println(&quot;鸟工作&quot;); &#125; @Override public void fly() &#123; System.out.println(&quot;鸟飞&quot;); &#125;&#125; 根据上面的写法发现Tony需要实现飞的接口，这很明显不仅仅是多余，而且不合理，因此需要通过接口隔离原则进行重构。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&#x2F;&#x2F;抽象动物的行为public interface IAnimal &#123; &#x2F;&#x2F; 吃饭 void eat(); &#x2F;&#x2F; 睡觉 void sleep();&#125;&#x2F;&#x2F; 高级动物人 的行为public interface IAdvancedAnimalBehavior &#123; &#x2F;&#x2F; 打牌 void playCard(); &#x2F;&#x2F; 骑车 void byBike();&#125;&#x2F;&#x2F;低级动物的行为public interface IJuniorAnimalBehavior &#123; &#x2F;&#x2F; fly void fly();&#125;&#x2F;&#x2F; 实现高级动物人的共通方法public class AbstractAdvancedAnimal implements IAnimal &#123; @Override public void eat() &#123; System.out.println(&quot;人吃&quot;); &#125; @Override public void sleep() &#123; System.out.println(&quot;人睡&quot;); &#125;&#125;&#x2F;&#x2F; 实现低级动物人的共通方法public class AbstractJuniorAnimal implements IAnimal &#123; @Override public void eat() &#123; System.out.println(&quot;动物吃&quot;); &#125; @Override public void sleep() &#123; System.out.println(&quot;动物睡&quot;); &#125;&#125;&#x2F;&#x2F; tonypublic class Tony extends AbstractAdvancedAnimal implements IAdvancedAnimalBehavior &#123; @Override public void playCard() &#123; System.out.println(&quot;tony打牌&quot;); &#125; @Override public void byBike() &#123; System.out.println(&quot;tony骑车&quot;); &#125;&#125;&#x2F;&#x2F; 鸟public class Bird extends AbstractJuniorAnimal implements IJuniorAnimalBehavior&#123; @Override public void fly() &#123; System.out.println(&quot;鸟飞&quot;); &#125;&#125; 重构之后，首先定义了一个总的动物接口的大类，然后分别使用了两个抽象类（一个是高级动物，一个是低级动物）分别去实现这些公共的方法，实现中可以抛出异常，表明继承此抽象类的类可以选择性的重写，可不重写。之后再定义了两个行为接口表明高级动物和低级动物所特有的，这样使得接口之间完全隔离，动物接口不再糅杂各种各样的角色，当然接口的大小尺度还是要靠经验来调整，不能太小，会造成接口泛滥，也不能太大，会背离接口隔离原则。 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"设计原则","slug":"设计原则","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"}],"tags":[{"name":"设计原则","slug":"设计原则","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"}]},{"title":"开闭原则","slug":"设计原则-开闭原则","date":"2021-03-05T13:02:06.595Z","updated":"2021-03-05T12:08:16.851Z","comments":false,"path":"article/20210705080741.html","link":"","permalink":"http://persian.gitee.io/blog/article/20210705080741.html","excerpt":"","text":"概念 对扩展开放，对修改关闭。即在尽量不修改原有代码的基础上进行扩展。 —— 代理模式是开闭原则的最佳实践。 优势 不影响原有代码逻辑的正确性。只需要测试扩展部分的代码； 可以提高代码的复用性； 可以提高系统的可维护性； 如何使用开闭原则 抽象约束 通过接口或者抽象类约束扩展，对扩展进行边界限定，不允许出现在接口或抽象类中不存在的public方法； 参数类型、引用对象尽量使用接口或者抽象类，而不是实现类；（针对抽象编程） 抽象层尽量保持稳定，一旦确定即不允许修改。 元数据控制模块行为 通俗来说就是通过配置文件来操作数据，spring的控制反转就是一个很典型的例子。 约定优于配置 封装变化 将相同的变化封装到一个接口或者类中 将不同的变化封装到不同的类或者接口中（单一职责的体现） 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"设计原则","slug":"设计原则","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"}],"tags":[{"name":"设计原则","slug":"设计原则","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"}]},{"title":"合成复用原则","slug":"设计原则-合成复用原则","date":"2021-03-05T13:02:06.593Z","updated":"2021-03-05T12:08:16.880Z","comments":false,"path":"article/20210705080708.html","link":"","permalink":"http://persian.gitee.io/blog/article/20210705080708.html","excerpt":"","text":"概念 合成复用原则(Composite Reuse Principle, CRP)： 尽量使用对象组合，而不是继承来达到复用的目的。 通过合成复用原则来使一些已有的对象使之成为对象的一部分，一般通过组合/聚合关系来实现，而尽量不要使用继承。因为组合和聚合可以降低类之间的耦合度，而继承会让系统更加复杂，最重要的一点会破坏系统的封装性，因为继承会把基类的实现细节暴露给子类，同时如果基类变化，子类也必须跟着改变，而且耦合度会很高。 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"设计原则","slug":"设计原则","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"}],"tags":[{"name":"设计原则","slug":"设计原则","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"}]},{"title":"单一职责原则","slug":"设计原则-单一职责原则","date":"2021-03-05T13:02:06.592Z","updated":"2021-03-05T12:08:16.892Z","comments":false,"path":"article/20210605080651.html","link":"","permalink":"http://persian.gitee.io/blog/article/20210605080651.html","excerpt":"","text":"概念 不要存在多于一个导致类变更的原因。通俗的说，即一个类只负责一项职责。 问题举例以及按照原则的处理办法问题由来 类T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。 解决方案 遵循单一职责原则。分别建立两个类T1、T2，使T1完成职责P1功能，T2完成职责P2功能。这样，当修改类T1时，不会使职责P2发生故障风险；同理，当修改T2时，也不会使职责P1发生故障风险。 说到单一职责原则，很多人都会不屑一顾。因为它太简单了。稍有经验的程序员即使从来没有读过设计模式、从来没有听说过单一职责原则，在设计软件时也会自觉的遵守这一重要原则，因为这是常识。在软件编程中，谁也不希望因为修改了一个功能导致其他的功能发生故障。而避免出现这一问题的方法便是遵循单一职责原则。虽然单一职责原则如此简单，并且被认为是常识，但是即便是经验丰富的程序员写出的程序，也会有违背这一原则的代码存在。为什么会出现这种现象呢？因为有职责扩散。所谓职责扩散，就是因为某种原因，职责P被分化为粒度更细的职责P1和P2。 遵循单一职责原的优点 可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多； 提高类的可读性，提高系统的可维护性； 变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响; 需要说明的一点是单一职责原则不只是面向对象编程思想所特有的，只要是模块化的程序设计，都适用单一职责原则。 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"设计原则","slug":"设计原则","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"}],"tags":[{"name":"设计原则","slug":"设计原则","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"}]},{"title":"依赖倒转原则","slug":"设计原则-依赖倒置原则","date":"2021-03-05T13:02:06.590Z","updated":"2021-03-05T12:08:16.904Z","comments":false,"path":"article/20210605080610.html","link":"","permalink":"http://persian.gitee.io/blog/article/20210605080610.html","excerpt":"","text":"概念 依赖倒转原则(Dependency Inversion Principle, DIP)：抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。 通俗的定义有两种: 高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。 抽象不应该依赖于具体实现，具体实现应该依赖于抽象。 启发 在设计程序的时候尽量使用层次高的抽象层类。即使用接口和抽象类进行变量的声明、参数类型声明、方法返回类型声明以及数据类型转换等等。即，要注意一个具体类应该只实现抽象类或者接口中存在的方法，不要给出多余的方法，否则抽象类将无法调用子类增加的方法。我们可以通过配置文件来写入具体类，这样一旦程序行为改变，可直接改变配置文件，而不需要更改程序，重新编译，通过依赖倒转原则来满足开闭原则。 在实现依赖倒转原则时，我们需要针对抽象层编程，而将具体类的对象通过依赖注入(DependencyInjection, DI)的方式注入到其他对象中。依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式有三种：：构造注入、设值注入（Setter注入）、接口注入。 12345678910111213141516171819202122232425&#x2F;&#x2F; 顶层类，或为接口，或为抽象类public interface IUser&#123;&#125;&#x2F;&#x2F; 实现类public class UserImpl implements IUser&#123;&#125;&#x2F;&#x2F; 遵循依赖倒转原则public class Test&#123; &#x2F;&#x2F; 构造注入 private IUser iuser &#x3D; new UserImpl(); &#x2F;&#x2F; setter注入 public void setIUser(UserImpl userImpl)&#123; this.iuser &#x3D; userImpl; &#125; &#x2F;&#x2F; 接口注入 public void save(IUser iuser)&#123; &#125;&#125; 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"设计原则","slug":"设计原则","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"}],"tags":[{"name":"设计原则","slug":"设计原则","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"}]},{"title":"","slug":"行为型模式-迭代器模式","date":"2021-03-05T13:02:06.589Z","updated":"2021-03-05T12:36:34.566Z","comments":false,"path":"article/20210305205834.html","link":"","permalink":"http://persian.gitee.io/blog/article/20210305205834.html","excerpt":"","text":"这里是内容 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[],"tags":[]},{"title":"责任链模式","slug":"行为型模式-责任链模式","date":"2021-03-05T13:02:06.588Z","updated":"2021-03-05T12:36:34.611Z","comments":false,"path":"article/20210305203603.html","link":"","permalink":"http://persian.gitee.io/blog/article/20210305203603.html","excerpt":"","text":"这里是内容 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"行为型模式","permalink":"http://persian.gitee.io/blog/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"访问者模式","slug":"行为型模式-访问者模式","date":"2021-03-05T13:02:06.587Z","updated":"2021-03-05T12:36:34.655Z","comments":false,"path":"article/20210305202534.html","link":"","permalink":"http://persian.gitee.io/blog/article/20210305202534.html","excerpt":"","text":"这里是内容 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"行为型模式","permalink":"http://persian.gitee.io/blog/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"解释器模式","slug":"行为型模式-解释器模式","date":"2021-03-05T13:02:06.586Z","updated":"2021-03-05T12:36:34.702Z","comments":false,"path":"article/20210305200834.html","link":"","permalink":"http://persian.gitee.io/blog/article/20210305200834.html","excerpt":"","text":"这里是内容 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"行为型模式","permalink":"http://persian.gitee.io/blog/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"观察者模式","slug":"行为型模式-观察者模式","date":"2021-03-05T13:02:06.584Z","updated":"2021-03-05T12:34:11.782Z","comments":false,"path":"article/20210305205733.html","link":"","permalink":"http://persian.gitee.io/blog/article/20210305205733.html","excerpt":"","text":"这里是内容 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"行为型模式","permalink":"http://persian.gitee.io/blog/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"策略模式","slug":"行为型模式-策略模式","date":"2021-03-05T13:02:06.583Z","updated":"2021-03-05T12:34:11.534Z","comments":false,"path":"article/20210305204333.html","link":"","permalink":"http://persian.gitee.io/blog/article/20210305204333.html","excerpt":"","text":"这里是内容 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"行为型模式","permalink":"http://persian.gitee.io/blog/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"状态模式","slug":"行为型模式-状态模式","date":"2021-03-05T13:02:06.582Z","updated":"2021-03-05T12:34:11.407Z","comments":false,"path":"article/20210305203133.html","link":"","permalink":"http://persian.gitee.io/blog/article/20210305203133.html","excerpt":"","text":"这里是内容 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"行为型模式","permalink":"http://persian.gitee.io/blog/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"模板模式","slug":"行为型模式-模板模式","date":"2021-03-05T13:02:06.580Z","updated":"2021-03-05T12:34:11.700Z","comments":false,"path":"article/20210305204532.html","link":"","permalink":"http://persian.gitee.io/blog/article/20210305204532.html","excerpt":"","text":"这里是内容 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"行为型模式","permalink":"http://persian.gitee.io/blog/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"备忘录模式","slug":"行为型模式-备忘录模式","date":"2021-03-05T13:02:06.579Z","updated":"2021-03-05T12:34:11.745Z","comments":false,"path":"article/20210305201732.html","link":"","permalink":"http://persian.gitee.io/blog/article/20210305201732.html","excerpt":"","text":"这里是内容 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"行为型模式","permalink":"http://persian.gitee.io/blog/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"命令模式","slug":"行为型模式-命令模式","date":"2021-03-05T13:02:06.578Z","updated":"2021-03-05T12:34:11.663Z","comments":false,"path":"article/20212205082242.html","link":"","permalink":"http://persian.gitee.io/blog/article/20212205082242.html","excerpt":"","text":"这里是内容 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"行为型模式","permalink":"http://persian.gitee.io/blog/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"中介者模式","slug":"行为型模式-中介者模式","date":"2021-03-05T13:02:06.576Z","updated":"2021-03-05T12:34:11.498Z","comments":false,"path":"article/20212205082219.html","link":"","permalink":"http://persian.gitee.io/blog/article/20212205082219.html","excerpt":"","text":"这里是内容 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"行为型模式","permalink":"http://persian.gitee.io/blog/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"适配器模式","slug":"结构型模式-适配器模式","date":"2021-03-05T13:02:06.574Z","updated":"2021-03-05T12:34:11.628Z","comments":false,"path":"article/20211905081917.html","link":"","permalink":"http://persian.gitee.io/blog/article/20211905081917.html","excerpt":"","text":"这里是内容 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"结构型模式","permalink":"http://persian.gitee.io/blog/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"装饰模式","slug":"结构型模式-装饰模式","date":"2021-03-05T13:02:06.573Z","updated":"2021-03-05T12:34:11.453Z","comments":false,"path":"article/20211805081847.html","link":"","permalink":"http://persian.gitee.io/blog/article/20211805081847.html","excerpt":"","text":"这里是内容 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"结构型模式","permalink":"http://persian.gitee.io/blog/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"组合模式","slug":"结构型模式-组合模式","date":"2021-03-05T13:02:06.572Z","updated":"2021-03-05T12:34:11.580Z","comments":false,"path":"article/20211805081829.html","link":"","permalink":"http://persian.gitee.io/blog/article/20211805081829.html","excerpt":"","text":"这里是内容 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"结构型模式","permalink":"http://persian.gitee.io/blog/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"桥接模式","slug":"结构型模式-桥接模式","date":"2021-03-05T13:02:06.571Z","updated":"2021-03-05T12:17:48.578Z","comments":false,"path":"article/20211705081738.html","link":"","permalink":"http://persian.gitee.io/blog/article/20211705081738.html","excerpt":"","text":"这里是内容 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"结构型模式","permalink":"http://persian.gitee.io/blog/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"外观模式","slug":"结构型模式-外观模式","date":"2021-03-05T13:02:06.569Z","updated":"2021-03-05T12:17:48.799Z","comments":false,"path":"article/20211705081715.html","link":"","permalink":"http://persian.gitee.io/blog/article/20211705081715.html","excerpt":"","text":"这里是内容 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"结构型模式","permalink":"http://persian.gitee.io/blog/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"代理模式","slug":"结构型模式-代理模式","date":"2021-03-05T13:02:06.568Z","updated":"2021-03-05T12:17:48.421Z","comments":false,"path":"article/20211605081641.html","link":"","permalink":"http://persian.gitee.io/blog/article/20211605081641.html","excerpt":"","text":"概念 代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。通俗的来讲代理模式就是我们生活中常见的中介。 为什么要用代理模式？ 中介隔离作用： 在某些情况下，一个客户类不想或者不能直接引用一个委托对象，而代理类对象可以在客户类和委托对象之间起到中介的作用，其特征是代理类和委托类实现相同的接口。 开闭原则，增加功能： (用于AOP) 代理类除了是客户类和委托类的中介之外，我们还可以通过给代理类增加额外的功能来扩展委托类的功能，这样做我们只需要修改代理类而不需要再修改委托类，符合代码设计的开闭原则。代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后对返回结果的处理等。代理类本身并不真正实现服务，而是同过调用委托类的相关方法，来提供特定的服务。真正的业务功能还是由委托类来实现，但是可以在业务功能执行的前后加入一些公共的服务。例如我们想给项目加入缓存、日志这些功能，我们就可以使用代理类来完成，而没必要打开已经封装好的委托类。 有哪几种代理模式？ 静态代理 动态代理（JDK接口代理） cglib动态代理 1. 静态代理 需要定义接口或父类； 代理对象与目标对象需要实现（或继承）同一个接口（或父类）； 缺点： 接口（或父类）改变时，代理对象与目标对象据需要一起改动； 每个目标对象均需要创建相应的代理对象，不方便的源码的管理，并且编译的class包也比较臃肿； 2. 动态代理 在动态代理中，我们不需要再为目标对象创建相应的代理对象，只需要创建一个代理对象生成工厂即可。真正的代理对象，JDK运行时会为我们动态创建。 需要实现接口InvocationHandler.invoke() – 里面写一些增强处理的逻辑。 自定义的代理工厂，使用 Proxy.newProxyInstance(接口对象的ClassLoader,接口对象的Class&lt;?&gt;[],InvocationHandler实现类)动态创建目标对象的代理对象； 缺点： 由于动态代理也叫JDK接口代理，字面意思也说明了，目标对象必须是某个接口的实现类； 3. cglib动态代理 – 子类代理 由于JDK实现动态代理需要实现类通过接口定义业务方法，对于没有接口的类，如何实现动态代理呢，这就需要CGLib了。CGLib采用了非常底层的字节码技术，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。但因为采用的是继承，所以不能对final修饰的类进行代理，并且被final修饰的方法，也不会被拦截。JDK动态代理与CGLib动态代理均是实现Spring AOP的基础。 ① 实现接口MethodInterceptor，里面放一些增强处理的逻辑 ② 使用Enhancer创建目标类子类代理对象，并把实现了MethodInterceptor接口的实现类对象，放入enhancer.setCallback()中； 总结： CGLIB创建的动态代理对象比JDK创建的动态代理对象的性能更高，但是CGLIB创建代理对象时所花费的时间却比JDK多得多。所以对于单例的对象，因为无需频繁创建对象，用CGLIB合适，反之使用JDK方式要更为合适一些。同时由于CGLib由于是采用动态创建子类的方法，对于final修饰的方法无法进行代理。 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"结构型模式","permalink":"http://persian.gitee.io/blog/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"亨元模式","slug":"结构型模式-亨元模式","date":"2021-03-05T13:02:06.567Z","updated":"2021-03-05T12:17:48.870Z","comments":false,"path":"article/20211505081524.html","link":"","permalink":"http://persian.gitee.io/blog/article/20211505081524.html","excerpt":"","text":"这里是内容 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"结构型模式","permalink":"http://persian.gitee.io/blog/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"抽象工厂模式","slug":"创建型模式-抽象工厂模式","date":"2021-03-05T13:02:06.565Z","updated":"2021-03-05T12:17:48.635Z","comments":false,"path":"article/20211505081501.html","link":"","permalink":"http://persian.gitee.io/blog/article/20211505081501.html","excerpt":"","text":"这里是内容 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"创建型模式","slug":"创建型模式","permalink":"http://persian.gitee.io/blog/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"建造者模式","slug":"创建型模式-建造者模式","date":"2021-03-05T13:02:06.564Z","updated":"2021-03-05T12:17:48.683Z","comments":false,"path":"article/20211405081445.html","link":"","permalink":"http://persian.gitee.io/blog/article/20211405081445.html","excerpt":"","text":"这里是内容 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"创建型模式","slug":"创建型模式","permalink":"http://persian.gitee.io/blog/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"工厂方法模式","slug":"创建型模式-工厂方法模式","date":"2021-03-05T13:02:06.563Z","updated":"2021-03-05T12:17:48.970Z","comments":false,"path":"article/20211405081412.html","link":"","permalink":"http://persian.gitee.io/blog/article/20211405081412.html","excerpt":"","text":"这里是内容 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"创建型模式","slug":"创建型模式","permalink":"http://persian.gitee.io/blog/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"原型模式","slug":"创建型模式-原型模式","date":"2021-03-05T13:02:06.561Z","updated":"2021-03-05T12:17:48.917Z","comments":false,"path":"article/20211305081317.html","link":"","permalink":"http://persian.gitee.io/blog/article/20211305081317.html","excerpt":"","text":"这里是内容 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"创建型模式","slug":"创建型模式","permalink":"http://persian.gitee.io/blog/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"单例模式","slug":"创建型模式-单例模式","date":"2021-03-05T13:02:06.558Z","updated":"2021-03-06T03:22:02.792Z","comments":false,"path":"article/20211205081216.html","link":"","permalink":"http://persian.gitee.io/blog/article/20211205081216.html","excerpt":"","text":"概念 GOF书中提到的定义： 保证一个类仅有一个实例，并提供一个访问它的全局访问点。解释如下： 单例类只能有一个实例； 单例类必须自己创建自己的唯一实例； 单例类必须给所有的其他对象提供自己这唯一的实例。(由于这个唯一实例是供全局使用的，那么这对象注定被static关键修饰的) 应用场景 单例模式确保某个类只有一个实例，而且自行实例化，并向整个系统提供这个实例。在计算机系统中，线程池、缓存、日至对象、对话框、打印机、显卡驱动程序的对象常被设计为单例模式。这些应用或多或少的具备系统资源管理器的功能。每台计算机可以有若干个打印机，但只能有一个Printer Spooler，以避免两个打印作业同时输出到打印机中。每台计算机可以有若干通信端口，系统应当集中管理这些通信端口，以避免一个通信端口同时被两个请求同时调用。总之，选择单例模式就是为了避免不一致状态，避免政出多头。 4种方式一、懒汉式单例 懒汉式，顾名思义就是实例在用到的时候才去创建，“比较懒”，用的时候才去检查有没有实例，如果有则返回，没有则新建。有线程安全和线程不安全两种写法，区别就是synchronized关键字。 12345678910111213//懒汉式单例类.在第一次调用的时候实例化自己 public class Singleton &#123; private Singleton() &#123;&#125; private static Singleton single=null; //静态工厂方法 -- 注：下面的关于线程安全的问题，会在这个方法进行改造 public static Singleton getInstance() &#123; if (single == null) &#123; single = new Singleton(); &#125; return single; &#125;&#125; Singleton通过将构造方法限定为private避免了类在外部被实例化，在同一个虚拟机范围内，Singleton的唯一实例只能通过getInstance()方法访问。 （事实上，通过Java反射机制是能够实例化构造方法为private的类的，那基本上会使所有的Java单例实现失效。） 但是以上懒汉式单例的实现没有考虑线程安全问题，它是线程不安全的，并发环境下很可能出现多个Singleton实例，要实现线程安全，有以下三种方式，都是对getInstance这个方法改造，保证了懒汉式单例的线程安全。(这里需要有对线程知识的了解。) 1. 在getInstance方法上加同步12345public static synchronized Singleton getInstance() &#123; if (single &#x3D;&#x3D; null) &#123; single &#x3D; new Singleton(); &#125; return single; 2. 双重检查锁定 双检锁，又叫双重校验锁，综合了懒汉式和饿汉式两者的优缺点整合而成。在下面代码实现中，特点是在synchronized关键字内外都加了一层if条件判断，这样既保证了线程安全，又比直接上锁提高了执行效率，还节省了内存空间。 12345678910public static Singleton getInstance() &#123; if (singleton &#x3D;&#x3D; null) &#123; synchronized (Singleton.class) &#123; if (singleton &#x3D;&#x3D; null) &#123; singleton &#x3D; new Singleton(); &#125; &#125; &#125; return singleton;&#125; 3. 静态内部类 静态内部类的方式效果类似双检锁，但实现更简单。但这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。 123456789public class Singleton &#123; private static class LazyHolder &#123; private static final Singleton INSTANCE &#x3D; new Singleton(); &#125; private Singleton ()&#123;&#125; public static final Singleton getInstance() &#123; return LazyHolder.INSTANCE; &#125; &#125; 这种比上面1、2都好一些，既实现了线程安全，又避免了同步带来的性能影响。 二、饿汉式单例 饿汉式，从名字上也很好理解，就是“比较勤”，实例在初始化的时候就已经建好了，不管你有没有用到，都先建好了再说。好处是没有线程安全的问题，坏处是浪费内存空间。 12345678910//饿汉式单例类.在类初始化时，已经自行实例化 public class Singleton1 &#123; private Singleton1() &#123;&#125; //final关键字决定了，这是一个静态对象，天生线程安全的。 private static final Singleton1 single = new Singleton1(); //静态工厂方法 public static Singleton1 getInstance() &#123; return single; &#125;&#125; 三、登记式单例(可忽略)12345678910111213141516171819202122232425262728293031323334353637//类似Spring里面的方法，将类名注册，下次从里面直接获取。public class Singleton3 &#123; private static Map&lt;String,Singleton3&gt; map = new HashMap&lt;String,Singleton3&gt;(); static&#123; Singleton3 single = new Singleton3(); map.put(single.getClass().getName(), single); &#125; //保护的默认构造子 protected Singleton3()&#123;&#125; //静态工厂方法,返还此类惟一的实例 public static Singleton3 getInstance(String name) &#123; if(name == null) &#123; name = Singleton3.class.getName(); System.out.println(&quot;name == null&quot;+&quot;---&gt;name=&quot;+name); &#125; if(map.get(name) == null) &#123; try &#123; map.put(name, (Singleton3) Class.forName(name).newInstance()); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; return map.get(name); &#125; //一个示意性的商业方法 public String about() &#123; return &quot;Hello, I am RegSingleton.&quot;; &#125; public static void main(String[] args) &#123; Singleton3 single3 = Singleton3.getInstance(null); System.out.println(single3.about()); &#125;&#125; 登记式单例实际上维护了一组单例类的实例，将这些实例存放在一个Map（登记薄）中，对于已经登记过的实例，则从Map直接返回，对于没有登记的，则先登记，然后返回。 这里我对登记式单例标记了可忽略，我的理解来说，首先它用的比较少，另外其实内部实现还是用的饿汉式单例，因为其中的static方法块，它的单例在类被装载的时候就被实例化了。 四、枚举类式单例12345678910public enum SingletonEnum &#123; ; private String code; private String desc; public SingletonEnum(String code,String desc)&#123; this.code = code; this.desc = desc; &#125;&#125; 枚举的方式是比较少见的一种实现方式，但是看上面的代码实现，却更简洁清晰。并且她还自动支持序列化机制，绝对防止多次实例化。 区别对比称呼的角度 饿汉就是类一旦加载，就把单例初始化完成，保证getInstance的时候，单例是已经存在的了；懒汉比较懒，只有当调用getInstance的时候，才回去初始化这个单例。 线程安全的角度 饿汉式天生就是线程安全的，可以直接用于多线程而不会出现问题；懒汉式本身是非线程安全的，为了实现线程安全有几种写法，分别是上面的1、2、3，这三种实现在资源加载和性能方面有些区别。 资源加载和性能的角度 饿汉式在类创建的同时就实例化一个静态对象出来，不管之后会不会使用这个单例，都会占据一定的内存，但是相应的，在第一次调用时速度也会更快，因为其资源已经初始化完成;懒汉式顾名思义，会延迟加载，在第一次使用该单例的时候才会实例化对象出来，第一次调用时要做初始化，如果要做的工作比较多，性能上会有些延迟，之后就和饿汉式一样了。 至于1、2、3这三种实现又有些区别： 第1种，在方法调用上加了同步，虽然线程安全了，但是每次都要同步，会影响性能，毕竟99%的情况下是不需要同步的， 第2种，在getInstance中做了两次null检查，确保了只有第一次调用单例的时候才会做同步，这样也是线程安全的，同时避免了每次都同步的性能损耗 第3种，利用了classloader的机制来保证初始化instance时只有一个线程，所以也是线程安全的，同时没有性能损耗，所以一般我倾向于使用这一种。 题外话什么是线程安全？ 如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。或者说：一个类或者程序所提供的接口对于线程来说是原子操作，或者多个线程之间的切换不会导致该接口的执行结果存在二义性,也就是说我们不用考虑同步的问题，那就是线程安全的。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"创建型模式","slug":"创建型模式","permalink":"http://persian.gitee.io/blog/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"SpringBean","slug":"Spring-SpringBean","date":"2021-03-05T13:02:06.557Z","updated":"2021-03-05T12:03:50.532Z","comments":false,"path":"article/20210305080340.html","link":"","permalink":"http://persian.gitee.io/blog/article/20210305080340.html","excerpt":"","text":"概念 在Spring中，那些组成应用程序的主体及由SpringIOC容器所管理的对象，被称之为bean。简单地讲，bean 就是由 IOC 容器初始化、装配及管理的对象，除此之外，bean 就与应用程序中的其他对象没有什么区别了。而bean的定义以及bean相互间的依赖关系将通过配置元数据来描述。 Spring中的bean默认都是单例的，这些单例Bean在多线程程序下如何保证线程安全呢？ 例如: 对于Web应用来说，Web容器对于每个用户请求都创建一个单独的Sevlet线程来处理请求，引入Spring框架之后，每个Action都是单例的，那么对于Spring托管的单例Service Bean，如何保证其安全呢？ Spring的单例是基于BeanFactory也就是Spring容器的，单例Bean在此容器内只有一个，Java的单例是基于 JVM，每个 JVM 内只有一个实例。 Bean作用域 singleton: 在Spring IoC容器中仅存在一个Bean实例，Bean以单例方式存在，默认值; prototype: 每次从容器中调用Bean时，都返回一个新的实例，即每次调用getBean()时，相当于执行new XxxBean(); request: 每次HTTP请求都会创建一个新的Bean，该该作用域仅适用于WebApplicationContext环境; session: 同一个HTTP Session共享一个Bean，不同Session使用不同Bean，仅适用于WebApplicationContext环境; globalSession: 一般用于Portlet应用环境，该作用域仅适用于WebApplicationContext环境; 总结：* 五种作用域中，request、session 和 global session 三种作用域仅在基于web的应用中使用（不必关心你所采用的是什么web应用框架），只能用在基于web的Spring ApplicationContext环境。 Spring Bean生命周期 概括 实例化 Instantiation 属性赋值 Populate 初始化 Initialization 销毁 Destruction注：前三步在doCreate()方法中: //忽略了无关代码 protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args) throws BeanCreationException &#123; // Instantiate the bean. BeanWrapper instanceWrapper = null; if (instanceWrapper == null) &#123; // 实例化阶段！ instanceWrapper = createBeanInstance(beanName, mbd, args); &#125; // Initialize the bean instance. Object exposedObject = bean; try &#123; // 属性赋值阶段！ populateBean(beanName, mbd, instanceWrapper); // 初始化阶段！ exposedObject = initializeBean(beanName, exposedObject, mbd); &#125; &#125; 详细的说 Bean容器找到配置文件中 Spring Bean 的定义。 Bean容器利用Java Reflection API创建一个Bean的实例。 如果涉及到一些属性值 利用set方法设置一些属性值。 如果Bean实现了BeanNameAware接口，调用setBeanName()方法，传入Bean的名字。 如果Bean实现了BeanClassLoaderAware接口，调用setBeanClassLoader()方法，传入ClassLoader对象的实例。 如果Bean实现了BeanFactoryAware接口，调用setBeanClassLoader()方法，传入ClassLoader对象的实例。 与上面的类似，如果实现了其他*Aware接口，就调用相应的方法。 如果有和加载这个Bean的Spring容器相关的BeanPostProcessor对象，执行postProcessBeforeInitialization()方法。 如果Bean实现了InitializingBean接口，执行afterPropertiesSet()方法。 如果Bean在配置文件中的定义包含init-method属性，执行指定的方法。 如果有和加载这个Bean的Spring容器相关的BeanPostProcessor对象，执行postProcessAfterInitialization()方法。 当要销毁Bean的时候，如果Bean实现了DisposableBean接口，执行destroy()方法。 当要销毁Bean的时候，如果Bean在配置文件中的定义包含destroy-method属性，执行指定的方法。 Spring中的单例Bean是线程安全的吗？ Spring容器中的Bean是否线程安全，容器本身并没有提供Bean的线程安全策略。因此可以说Spring容器中的Bean本身不具备线程安全的特性，但是具体还是要结合具体scope的Bean去研究。 线程安全这个问题，要从单例与原型Bean分别进行说明。 原型Bean： 对于原型Bean,每次创建一个新对象，也就是线程之间并不存在Bean共享，自然是不会有线程安全的问题。 单例Bean： 对于单例Bean,所有线程都共享一个单例实例Bean,因此是存在资源的竞争。 无状态的单例Bean：也就是线程中的操作不会对Bean的成员执行查询以外的操作，那么这个单例Bean是线程安全的。比如Spring mvc 的 Controller、Service、Dao等，这些Bean大多是无状态的，只关注于方法本身。 有状态的单例Bean：就是没有实例变量的对象，不能保存数据，是不变类，是线程安全的。bean一旦实例化就被加进会话池中，各个用户都可以共用。即使用户已经消亡，bean 的生命期也不一定结束，它可能依然存在于会话池中，供其他用户调用。由于没有特定的用户，那么也就不能保持某一用户的状态，所以叫无状态bean。但无状态会话bean 并非没有状态，如果它有自己的属性（变量），那么这些变量就会受到所有调用它的用户的影响，这是在实际应用中必须注意的。 那么对于有状态的单例Bean，如何保证线程安全？ Spring官方提供的bean，一般提供了通过ThreadLocal去解决线程安全的方法。 比如RequestContextHolder、TransactionSynchronizationManager、LocaleContextHolder等。 使用ThreadLocal的好处使得多线程场景下，多个线程对这个单例Bean的成员变量并不存在资源的竞争，因为ThreadLocal为每个线程保存线程私有的数据。这是一种以空间换时间的方式。当然也可以通过加锁的方法来解决线程安全，这种以时间换空间的场景在高并发场景下显然是不实际的。 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://persian.gitee.io/blog/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://persian.gitee.io/blog/tags/spring/"},{"name":"bean","slug":"bean","permalink":"http://persian.gitee.io/blog/tags/bean/"}]},{"title":"Java基础","slug":"Java基础","date":"2021-03-05T13:02:06.555Z","updated":"2021-03-05T12:17:48.710Z","comments":false,"path":"article/20213903103930.html","link":"","permalink":"http://persian.gitee.io/blog/article/20213903103930.html","excerpt":"","text":"1.⾯向对象和⾯向过程的区别？① ⾯向过程 ⾯向过程性能⽐⾯向对象⾼。 因为类调⽤时需要实例化，开销比较⼤，比较消耗资源，所以当性能是最重要的考量因素的时候，⽐如单⽚机、嵌⼊式开发、Linux/Unix 等⼀般采⽤⾯向过程开发。但是⾯向过程没有⾯向对象易维护、易复⽤、易扩展。 ② ⾯向对象 ⾯向对象易维护、易复⽤、易扩展。 2.java抽象类和普通类的区别？① 抽象类可以有构造函数，抽象方法不能被声明为静态② 象类不能被实例化3.Java 方法访问权限修饰？① private私有成员属性和方法，只有本类可以调用，除内部类特殊情况② 默认不写只有本类 同一个包下面的类③ protected本类 同包 不同包的子类④ public 本类 同包 不同包的类 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://persian.gitee.io/blog/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://persian.gitee.io/blog/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"Java集合","slug":"Java基础-集合","date":"2021-03-05T13:02:06.554Z","updated":"2021-03-05T12:17:48.592Z","comments":false,"path":"article/20211903111947.html","link":"","permalink":"http://persian.gitee.io/blog/article/20211903111947.html","excerpt":"","text":"CollectionListArraylist 动态数组 能够实现随机存取 – 实现了RandomAccess接口 fail-fast机制① modCount在Abstractlist中定义② 在使用迭代器遍历list时，如果modCount和exceptedCount不匹配，就会直接抛出异常③ 使用迭代器自带的remove时，如果删除了list中元素，不会出现fail-fast， 因为迭代器会调整modCount和expectedCount值 自定义序列化方法① 因为arraylist的底层数组中，可能存在值为null的元素，序列化这些元素是没意义的， 因此自定义序列化方法，只序列化数组中非null的元素② 通过readObject和writeObject方法实现 有一个初始容量（16）① 扩容：capacity = 1.5 * capacity② 通过Arrays.copyOf() - &gt; System.copyOf()③ Arraylist是插入前扩容，扩容逻辑为ensureCapacityInternal() –&gt; ensureExplicitCapacity() —&gt; grow() 插入时，判断容器中的元素是否超过某个阈值，超过则代表快溢出，会进行扩容 Linkedlist 动态数组 双向链表 不能随机访问，不能通过下标获取元素 适合插入删除多的场合 – 更新，删除元素效率高 SetHashSet 不保证元素顺序 元素插入的顺序与输出顺序不一致 在Set中元素还是有顺序的，根据元素的hashcode排序 LinkedHashSet 基于LinkedHashMap实现 使用链表维护元素的次序 TreeSet 底层基于TreeMap实现 两种排序：① 自然排序 ② 定制排序 不是通过hashcodeh和equals来比较元素，是通过compare或compareTo来判断元素是否相等 MapHashMap 扩容，需要遍历旧table，再遍历每个table中每个元素的单向链表，取得entry后，重新计算hash，然后存放到新table的对应位置 LinkedHashMap 哈希表和链表实现 每个元素用双向链表进行连接 扩容时遍历双向链表，重新计算每个元素的hash即可 TreeMap 基于红黑树 自然排序 ① 所有key必须实现Comparable接口 – 每一个key-value节点作为红黑树的一个节点 定制排序 ① 定义TreeMap时，创建一个comparator对象，该对象对所有的key进行排序 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://persian.gitee.io/blog/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://persian.gitee.io/blog/tags/%E5%9F%BA%E7%A1%80/"},{"name":"集合","slug":"集合","permalink":"http://persian.gitee.io/blog/tags/%E9%9B%86%E5%90%88/"}]},{"title":"Java高级特性——反射","slug":"Java基础-反射","date":"2021-03-05T13:02:06.552Z","updated":"2021-03-05T12:00:37.466Z","comments":false,"path":"article/20215805075828.html","link":"","permalink":"http://persian.gitee.io/blog/article/20215805075828.html","excerpt":"","text":"概念 java反射机制是指在运行状态中，对于任意一个类，都能够知道这类的所有属性和方法；对于任意一个对象，都能够调用它的所有属性和方法。 —— 对于这种动态的获取任意类的信息和动态的调用其方法的功能，称为java语言的反射机制。 反射机制类 Class – 类，三种获取方式 Feild – 成员变量类 Method – 方法类 Constructor – 构造方法类 Modifier – 访问权限类 反射机制提供了哪些功能？ 在运行时，判定任意对象所属的类 –Class 在运行时，构造任意一个类的对象 –对象5种创建方式：Class.newInstance() 在运行时，判定任意对象的所有方法和成员变量 – Feild、Method 在运行时，调用任意对象的方法 – Method 生成动态代理 Java反射机制的应用 ① class对象的获取; 1object.getClass()、Object.class、Class.forName(&quot;java.lang.Object&quot;) ② 获取class对象的摘要信息 12345678910111213class1.isPrimitive();&#x2F;&#x2F;是否基础类型class1.isArray();&#x2F;&#x2F;是否集合类class1.isAnnotation();&#x2F;&#x2F;是否注解类class1.isInterface();&#x2F;&#x2F;是否接口类class1.isEnum();&#x2F;&#x2F;是否枚举类class1.isAnonymousClass();&#x2F;&#x2F;是否匿名内部类class1.isAnnotationPresent(Deprecated.class);&#x2F;&#x2F;是否被某个注解类修饰class1.getName();&#x2F;&#x2F;获取class名字 包含包名路径class1.getPackage();&#x2F;&#x2F;获取class的包信息class1.getSimpleName();&#x2F;&#x2F;获取class类名class1.getModifiers();&#x2F;&#x2F;获取class访问权限class1.getDeclaredClasses();&#x2F;&#x2F;内部类class1.getDeclaringClass();&#x2F;&#x2F;外部类 ③ 获取class对象的属性、方法、构造函数等;④ class对象动态生成;⑤ 动态调用函数;⑥ 通过反射机制获取泛型类型;⑦ 通过反射机制获取注解信息; 用途 逆向代码，如反编译 配合注解：spring mybatis 等 动态生成类框架：hibernate等 AOP的核心技术 优点与缺陷 优点： 运行期类型的判断，动态类加载，动态代理使用反射。 缺陷： 性能是一个问题，反射相当于一系列解释操作，通知jvm要做的事情，性能比直接的java代码要慢很多。 总结 Java的反射机制在平时的业务开发过程中很少使用到，但是在一些基础框架的搭建上应用非常广泛 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://persian.gitee.io/blog/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://persian.gitee.io/blog/tags/%E5%9F%BA%E7%A1%80/"},{"name":"反射","slug":"反射","permalink":"http://persian.gitee.io/blog/tags/%E5%8F%8D%E5%B0%84/"}]},{"title":"JVM复习点","slug":"Java基础-JVM复习点","date":"2021-03-05T13:02:06.550Z","updated":"2021-03-05T12:17:48.983Z","comments":false,"path":"article/20213303113340.html","link":"","permalink":"http://persian.gitee.io/blog/article/20213303113340.html","excerpt":"","text":"类加载机制加载 全限定名获取定义此类的二进制流 静态存储结构转为方法区的数据结构 java堆中生成class对象作为入口验证 文件格式（魔数 版本 编码等） 元数据（集成关系 重载参数等） 字节码（指令跳转 类型转换等） 符号引用（全限定名找到对应类 其方法与字段 其访问性等）准备 类变量赋初值解析 常量池的符号引用替换为直接引用 类或接口 字段 类方法 接口方法的解析初始化 ()是类变量赋值动作和静态语句块的合并 类 ① 父类静态语句块优于子类变量赋值 ② JVM保证父类初始化已提取完成 接口 ① 仅当接口的变量被使用时才初始化 多线程中会加锁，一个线程执行初始化，其他线程阻塞等待使用 卸载类加载器 Bootstrap ClassLoader Extension ClassLoader Application ClassLoader 自定义类加载器双亲委派机制 1.避免类重复加载 2.避免java核心api被篡改 内存模型主内存和工作内存内存结构对象在jvm内存中如何分配和流转如何设置jvm参数GCyoung gc时机 eden区满触发old gc时机 老年代可用连续内存空间小于新生代历次 young gc进入老年代对象总和的平均大小 老年代空间不足 老年代使用率超92% full gc young gc + old gc + 永久代gc 频繁full gc 并发数过大，导致young gc频繁且存活对象太多，survivor区过小，对象频繁进入老年代 大对象过多 内存泄漏 - 类似集合之类一直无限制扩容，导致堆内存不够用 Metaspace加载类过多 误调用System.gc 条件 老年代内存超阈值（92%） 老年代可用空间小于历次young gc后升入老年代的平均对象大小 young gc存活对象过多，survivor放不下，老年代也放不下监控 zabbix、open-falcon工具监控 jstat监控 tomcat的catalina.sh配置打印gc命令，将gc日志导入MAT查看 垃圾回收算法新生代 Serial 复制算法 暂停所有工作线程 ParNew 多线程版的Serial Parallel Scavenge 采用复制算法 并行多线程 吞吐量优先 3.1. 吞吐量=代码时间/（代码时间+GC时间） 3.2. 吞吐量：更有效利用CPU 3.3. 停顿时间：适合与用户交互的程序 总结：复制算法 老年代 Serial Old 标记-整理算法 Parallel Old 标记-整理算法 并行多线程 吞吐量优先 CMS 标记-整理算法 目标为最小停顿时间 缺点: ① 对CPU资源非常敏感 ② 无法处理浮动垃圾 ③ 产生大量碎片 总结：标记整理 G1 标记整理 精确控制停顿 将整个堆划分为固定的区域 跟踪区域的垃圾堆积程度 优先回收垃圾最多的区域 垃圾回收器 新生代（ParNew） 老年代（CMS） G1 查看堆栈和gc情况的命令 jstat -gc pid 如何判断一个对象是否存活 GC Roots 虚拟机栈中引用的对象 方法区类静态属性引用的对象 方法区常量池引用的对象 本地方法栈JNI引用的对象 GC Roots没有引用是第一次标记，不会真正回收，如果没有执行finalize方法，才真正回收 对象进入老年代条件 默认15次young gc还没被回收 young gc过后，同龄对象大小超过survivor的50%，直接进入老年代 young gc后存活对象太多无法放入survivor 优化 加大新生代内存（特别是survivor内存），避免频繁进入老年代 减少躲过GC次数 降低大对象进入老年代的内存门槛 jdk8优化 将永久代放到本地内存中，将常量池和静态变量放到堆中 将类元数据放到本地内存，避免在反射、代理时造成经常full gc 原来每个项目都会占用自己永久代，同个class会占用多个内存空间；优化后metaspaces里只存一份class，提高内存利用率逃逸分析 是一种技术，在开启后，方法栈上的对象在方法执行完后，栈帧弹出，对象就会回收。这样就不需要等内存满时再触发内存回收 同步锁消除 如果发现某个对象只能从一个线程可访问，那么在这个对象上的操作可以不需要同步 逃逸分析把锁消除了 逃逸分析时方法级别，因为jit的即时编译是方法级别 分离对象或标量替换 把对象分解成一个个基本类型，并且内存分配不再是分配在堆上，而是分配在栈上 减少内存使用，因为不用生成对象头 程序内存回收效率高，GC频率减少 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://persian.gitee.io/blog/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://persian.gitee.io/blog/tags/%E5%9F%BA%E7%A1%80/"},{"name":"JVM","slug":"JVM","permalink":"http://persian.gitee.io/blog/tags/JVM/"}]},{"title":"JVM面试","slug":"Java基础-JVM","date":"2021-03-05T13:02:06.549Z","updated":"2021-03-05T12:17:48.537Z","comments":false,"path":"article/20213903103919.html","link":"","permalink":"http://persian.gitee.io/blog/article/20213903103919.html","excerpt":"","text":"1、说一下JVM的主要组成部分及其作用 JVM包括类装载子系统、运行时数据区、执行引擎、本地接口四个部分； 类装载子系统通过类加载器将class字节码加载到JVM运行时数据区的方法区（jdk1.8及以后改为了元空间）；运行时数据区用于存储程序运行时所产生的各种数据；执行引擎负责将class字节码解析为机器指令并交给CPU进行处理，这个过程中可能会调用到系统提供的native方法； 2、描述一下JVM运行时数据区（通常也被叫作JVM内存模型，要区别于Java内存模型~JMM） JVM运行时数据区主要包括堆区、方法区（jdk1.8及以后改为了元空间）、虚拟机栈、本地方法栈、程序计数器五个区域，其中堆区、方法区属于所有线程共享内存区域，虚拟机栈、本地方法栈、程序计数器属于每个线程独享的内存区域； 堆区用于存放对象实例； 方法区用于存储类信息、常量、静态变量、即时编译器编译后的代码等； 虚拟机栈用于存储一个线程在执行方法的过程中产生的数据，一个方法开始被调用就会有一个栈帧入栈，方法执行完毕栈帧出栈，栈帧中包括局部变量表、操作数栈、动态链接、方法出口等； 本地方法栈与虚拟机栈的作用类似，区别在于本地方法栈用于存储线程执行的native方法产生的数据； 程序计数器用于记录线程执行代码的位置，分支、循环、跳转、异常、线程恢复等都依赖于程序计数器，程序计数器也是JVM规范中唯一没有规定OOM（OutOfMemeryError）的内存区域。 3、说一下几种垃圾收集算法及其应用场景 垃圾收集算法主要有标记清除、标记整理、复制算法三种，还有一种分代收集的理论； 标记清除算法标记存活对象，然后清除无用对象，缺点是效率不高，会产生垃圾碎片，主要用于老年代收集，CMS垃圾收集器使用该算法实现； 标记整理算法标记存活对象，然后将存活对象向内存的一端移动，然后清理另一端的内存空间，优点是解决了标记清除算法产生碎片的问题，缺点是需要移动对象，一定程度上降低了垃圾收集效率，SerialOld、ParallelOld、G1收集器使用该算法实现； 复制算法将内存分为大小相等的两块，每次只使用其中的一块，在进行垃圾收集时，将存活对象复制到另一块空闲的内存区域，然后清除掉垃圾对象，复制算法主要应用于年轻代收集，因为年轻的对象大都是存活时间短，存活对象少，使用复制算法效率高，缺点是内存利用率低，Serial、ParNew、Parallel Scavenge收集器使用该算法实现。 4、说一下常见的垃圾收集器及其所使用的垃圾收集算法 目前常用的垃圾收集器大概有七种，其中年轻代垃圾收集器包括Serial、ParNew、Parallel Scavenge，这三种垃圾收集器使用复制算法实现，老年代收集器包括SerialOld、ParallelOld、CMS，其中SerialOld、ParallelOld使用标记整理算法实现，CMS使用标记清除算法实现，整堆垃圾收集器G1使用标记整理算法实现。 Serial是一种单线程垃圾收集器，标记和清理阶段都是单线程； Parallel Scavenge是一种并行垃圾收集器，可以理解为Serial的多线程版本，特点是吞吐量高； ParNew与Parallel Scavenge类似，但是由于Parallel Scavenge不能与CMS进行配合使用，所以才有了ParNew垃圾收集器； SerialOld是一种单线程垃圾收集器，标记和清理阶段都是单线程； ParallelOld是一种并行垃圾收集器，可以理解为Serial的多线程版本，特点是吞吐量高； CMS是一种以获取最短回收停顿时间为目标的收集器，主要包括初始标记、并发标记、重新标记、并发收集、并发清除五个阶段，初始标记扫描gcroot根对象，该阶段需要STW（Stop The World），并发标记基于初始标扫描的gcroot根对象继续查找，标记出所有与gcroot关联的存活对象，该阶段标记线程与用户线程并发执行，重新标记用于修复在并发标记过程中多标和漏标的情况，多标会产生浮动垃圾，可以在下一次GC进行清理，漏标则会清理存活对象，导致致命bug，漏标的情况在CMS中会使用三色标记中的增量更新进行处理，该阶段需要STW（Stop The World）。并发清理阶段清理线程与用户线程并发执行，用于清除在标记阶段为存活对象打的标记，用户线程新产生的对象会被直接标记为黑色不进行回收，CMS也可以通过参数配置进行内存整理等功能； 整堆收集器G1，使用标记整理算法实现（目前很少用，暂不做详细描述）。 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://persian.gitee.io/blog/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://persian.gitee.io/blog/tags/%E5%9F%BA%E7%A1%80/"},{"name":"JVM","slug":"JVM","permalink":"http://persian.gitee.io/blog/tags/JVM/"}]},{"title":"Java创建对象的5种方式","slug":"Java基础-java对象的创建","date":"2021-03-05T13:02:06.548Z","updated":"2021-03-05T12:00:37.486Z","comments":false,"path":"article/20215905075928.html","link":"","permalink":"http://persian.gitee.io/blog/article/20215905075928.html","excerpt":"","text":"方式 依赖函数 使用new关键字 } → 调用了构造函数 使用Class类的newInstance方法 } → 调用了构造函数 使用Constructor类的newInstance方法 } → 调用了构造函数 使用clone方法 } → 没有调用构造函数 使用反序列化——需要实现Serializable接口 } → 没有调用构造函数 举例 1.使用Constructor类的newInstance方法和Class类的newInstance方法很像， java.lang.reflect.Constructor类里也有一个newInstance方法可以创建对象 12Constructor&lt;Employee&gt; constructor &#x3D; Employee.class.getConstructor();Employee emp3 &#x3D; constructor.newInstance(); 2.使用clone方法无论何时我们调用一个对象的clone方法，jvm就会创建一个新的对象，将前面对象的内容全部拷贝进去。用clone方法创建对象并不会调用任何构造函数要使用clone方法，我们需要先实现Cloneable接口并实现其定义的clone方法 1Object o2 &#x3D; object.clone(); 3.使用反序列化当我们序列化和反序列化一个对象，jvm会给我们创建一个单独的对象。在反序列化时，jvm创建对象并不会调用任何构造函数 12ObjectInputStream in &#x3D; new ObjectInputStream(new FileInputStream(&quot;data.obj&quot;));Object object &#x3D; (Object) in.readObject(); 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://persian.gitee.io/blog/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://persian.gitee.io/blog/tags/%E5%9F%BA%E7%A1%80/"},{"name":"对象创建","slug":"对象创建","permalink":"http://persian.gitee.io/blog/tags/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA/"}]},{"title":"Java多线程","slug":"Java基础-Java多线程","date":"2021-03-05T13:02:06.547Z","updated":"2021-03-04T14:13:54.781Z","comments":false,"path":"article/20211204101246.html","link":"","permalink":"http://persian.gitee.io/blog/article/20211204101246.html","excerpt":"","text":"为什么使用多线程： ① 随着处理器的核心数不断增多，单线程程序已无法发挥多核处理器的优势； ② 线程比进程切换效率更高 概念进程 进程是程序一次执行过程。比如程序从启动到销毁是一个进程 线程 线程是比进程更小的单位。一个进程在执行过程中可以产生多个线程。线程之间可以共享“堆”和“Metadata Space”数据，但拥有独立的“程序计数器”、“虚拟机栈”和“本地方法栈”。所以线程之间切换比进程切换负担小的多 并发与并行① 并发 同一时间段内，多个任务都在执行。他们之间共享cpu的执行时间片段。多个任务之间并不是同时执行的。并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。 ② 并行 同一时刻，多个任务同时执行。可能有多个任务分别在不同的cpu上执行。并行可以充分利用多核处理器的优势 引入问题内存泄露 对象在使用完成后，对它的引用依然没有被释放，导致jvm无法回收该对象，就会造成内存泄漏 ① 静态集合类 静态集合类的生命周期和类一样，所以jvm无法回收它们 ② 数据库连接、网络连接、IO连接等 连接在使用完成后必须主动释放资源，否则jvm无法回收它们 ③ 变量不合理的作用域 变量设置的作用域过大，在对其的使用结束后，jvm依然无法对它进行回收，也有可能造成内存泄漏 ④ 内部类引用外部类 内部类保存对外部类的引用，即使程序已经没有对外部类的引用，也会因为内部类保存了引用而无法回收外部类。 死锁死锁发生条件 ① 互斥条件： 该资源任一时刻只能被一个线程拥有；② 请求与保持条件： 一个线程在获取资源阻塞时，对已获得的资源不释放;③ 不剥夺条件： 一个线程获得的资源在其使用完成之前不能被其他线程主动剥夺，只能由自己主动释放;④ 循环等待条件： 多个线程之间形成首尾相接的循环等待资源关系 避免死锁 只需要破坏四个条件中的任意一个即可:① 互斥条件： 本来就是让线程之间互斥，所以无法破坏;② 请求与保持条件： 一次性申请所有的资源;③ 不剥夺条件： 可以让线程在无法获得资源时，先把已获得资源进行释放;④ 循环等待条件： 按照某一顺序来获取资源 解决死锁 待补充。。。 上下文切换 一般情况下线程数都比cpu核心数要多，cpu只能不断在线程之间切换来执行每一个线程。cpu每次切换都得保存当前状态，和加载下一个线程的状态。这就是上下文切换 线程同步synchronized1. 作用范围 ① 静态方法： 使用的同步锁是类对象，和其他静态同步方法存在锁竞争; ② 非静态方法： 使用的锁是当前对象，同一对象之间存在锁竞争，不同对象之间不存在竞争关系；③ 代码块： 使用的锁是synchronized中传入的对象，依据是否同一对象而决定否存在竞争 2. 底层原理 ① 方法： 待补充..② 代码块： 每个java对象的对象头中都有monitor对象，通过能否获取到monitor对象来判断能否获取锁；. 3. 锁优化3.1. 自旋锁 当线程竞争锁失败时，不直接阻塞自己，而是自旋（空等待，比如一个有限的for循环）一会儿，在自旋的同时重新竞争锁。如果在自旋结束前获得了锁，那么获取锁成功；否则自旋结束后阻塞自己; 自旋锁可以减少线程阻塞造成的线程切换（包括挂起线程和恢复线程） ① 单核处理器情况下，不存在实际的并行。当前线程不阻塞自己，拥有锁的线程就无法执行，锁永远不会释放。进而，如果线程多而处理器少，自旋也会造成不少无谓的浪费；② 自旋锁要占用CPU，如果是计算密集型任务，这一优化通常得不偿失，减少锁的使用是更好的选择；③ 如果锁竞争时间比较长，那么自旋通常不能获得锁，白白浪费自旋占用的CPU时间。这通常发生在所持有时间长，且竞争激烈的场景中，此时应主动禁用自旋锁 使用-XX:-UseSpinning参数关闭自旋锁优化；-XX:PreBlockSpin参数修改默认的自旋次数。 3.2. 偏向锁 偏向锁的目标是减少无竞争且只有一个线程使用锁的情况下，使用轻量级锁产生的性能消耗； 在没有实际竞争的情况下，还能够针对部分场景继续优化。如果不仅仅没有实际竞争，自始至终，使用锁的线&gt; 程都只有一个，那么，维护轻量级锁都是浪费的。偏向锁的目标是，减少无竞争且只有一个线程使用锁的情况&gt; 下，使用轻量级锁产生的性能消耗。轻量级锁每次申请、释放锁都至少需要一次CAS，但偏向锁只有初始化时&gt; 需要一次CAS。 “偏向”的意思是，偏向锁假定将来只有第一个申请锁的线程会使用锁（不会有任何线程再来申请锁），因 此，只需要在Mark Word中CAS记录owner（本质上也是更新，但初始值为空），如果记录成功，则偏向锁获取成功，记录锁状态为偏向锁，以后当前线程等于owner就可以零成本的直接获得锁；否则，说明有其他线程竞争，膨胀为轻量级锁。 如果有其他线程申请锁，那么偏向锁很快就膨胀为轻量级锁。浪费了维持偏向锁的性能消耗 使用参数-XX:-UseBiasedLocking禁止偏向锁优化（默认打开）。 3.3. 轻量级锁 使用轻量级锁时，不需要申请互斥量，仅仅将Mark Word中的部分字节CAS更新指向线程栈中的Lock Record，如果更新成功，则轻量级锁获取成功。否则可以继续使用自旋锁获取或者升级为重量级锁; Mark Word是对象头的一部分；每个线程都拥有自己的线程栈（虚拟机栈），记录线程和函数调用的基本信息 轻量级锁的目标是减少无实际竞争的情况下，使用重量级锁产生的性能消耗; 如果锁竞争激烈，轻量级锁很快就将升级为重量级锁，那么维持轻量级锁的过程就成了浪费 3.4. 重量级锁 内置锁在Java中被抽象成监视器锁（monitor）。监视器锁直接对应底层操作系统的互斥量（mutex） 这种同步方式成本非常高，包括系统调用引起的内核态和用户态切换、线程阻塞造成的线程切换等 synchronized与ReentrantLock 两者都是可重入锁 synchronized依赖于JVM，ReentrantLock依赖于API ① synchronized是非公平锁; ② ReentrantLock可指定是公平锁或非公平锁 一个Lock对象可以创建多个Condition实例，线程对象可以注册在指定的Condition上，从而可以有选择性的进行通知 ReentrantLock比synchronized多一些高级功能 等待可中断ReentrantLock提供了一种可以中断等待锁的线程的机制。通过lock.lockInterruptibly()来实现。也就是使正在等待的线程可以放弃等待，改为处理其他事情; 可实现公平锁ReentrantLock可以指定是公平锁还是非公平锁。公平锁就是先等待的线程先获得锁，通过构造方法ReentrantLock(boolean fair)来实现; 可实现选择性通知 synchronized与volatile 并发编程的三个特性 ①原子性： 一个操作或者多次操作，要么都执行、要不都不执行。synchronized可以保证原子性②可见性： 当一个线程对共享变量进行了修改，其他线程可以马上看到最新的值。volatile可以保证可见性；③有序性： 代码在执行过程中，编译器会对字节码进行冲重排序优化，无法保证代码的执行顺序就是编写代码的顺序。volatile可以禁止指令重排； volatile是synchronized的轻量级实现 多线程访问volatile关键字不会阻塞，synchronized可能会阻塞 volatile能保证数据的可见性，不能保证原子性；synchronized两者都可以保证 volatile主要解决多线程之间数据的可见性问题；synchronized解决多线程之间数据的同步性问题 ThreadLocal 每个线程的专属变量，不会被其他线程访问到 ThreadLocal中有一个静态内部类ThreadLocalMap，可以理解为ThreadLocal的定制化HashMap实现。KEY为线程对象，Value为set进去的值 内存泄漏问题 ThreadLocalMap中的Key为ThreadLocal的弱引用，而Value是强引用。所以在ThreadLocal没有被外部强引用的时候，在垃圾回收时会把Key给回收掉，而Value却不会被回收。这样会出来Key为null的Entry。如果我们不做什么措施，Value就永远无法被回收，发生内存泄漏。ThreadLocal已经考虑了这种情况，在调用set()、get()和remove()方法时，会清理掉Key为null的Entry 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://persian.gitee.io/blog/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://persian.gitee.io/blog/tags/%E5%9F%BA%E7%A1%80/"},{"name":"多线程","slug":"多线程","permalink":"http://persian.gitee.io/blog/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"AOP","slug":"Java基础-AOP","date":"2021-03-05T13:02:06.545Z","updated":"2021-03-05T12:00:37.408Z","comments":false,"path":"article/20215905075902.html","link":"","permalink":"http://persian.gitee.io/blog/article/20215905075902.html","excerpt":"","text":"概念 面向切面编程，其作用是在不修改目标对象的情况下，进行逻辑扩展与增强。依赖代理模式（开闭原则的最好实践方式）核心技术是：反射。 原理 将复杂的需求分解出不同的方面（代码解耦），将抽离出来的逻辑，公共集中处理； 常见应用：权限控制，日志记录，持久化，事务等 在代理模式下，在不改变原程序的情况下，对目标对象进行逻辑增强、功能扩展等;综上：面向切面编程，是一种通过预编译方式和运行期动态代理的方式，在不修改目标代码的情况下，给程序动态增加功能的一种技术 已有框架 AspectJ SpringAOP AspectJ与SpringAOP的简单对比 区别： 织入时期不同： AspectJ – 静态织入 SpringAOP – 动态织入 目标对象不同: SpringAOP: 目标对象必须是SpringBean对象才可以； AspectJ: 可以是任何对象。 相关术语1. 增强处理 前置增强、后置增强、环绕增强、异常抛出增强、最终增强等。处理方式： 增强处理 ==&gt; 目标对象的方法 ==&gt; 增强处理 2. 切入点 SpringAOP通过一个表达式，去目标对象指定位置进行增强。可以把表达式认为一个查询条件或增加条件，表达式里面指定了目标对象的增强位置。 3. 连接点 SpringAOP通过切入点找到了目标对象要增强的代码位置，这个被切入的位置 – 连接点。 4. 切面 切面由一组增强处理和切入点共同组成。 5. 目标对象 目标对象即要被增强处理的目标类 – 也称委托类。 6. AOP代理 代理类即AOP代理，代理类里面包含了目标对象，以及对目标对象一些增强处理。– 代理类的执行逻辑，可参考代理模式。 7. 织入 织入就是指，将我们的增强处理，通过切入点编译到目标对象的连接点的过程。有静态织入和动态织入两种： 静态织入： 在编译时期就织入，即编译出来的class文件，字节码就已经被织入到了目标对象的连接点了。 – AspectJ 动态织入： 又分静动两种；– ApringAOP静表示织入过程只在第一次调用时执行；动表示根据代码动态运行的中间状态来决定如何操作，每次调用目标对象时都执行。 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://persian.gitee.io/blog/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://persian.gitee.io/blog/tags/%E5%9F%BA%E7%A1%80/"},{"name":"AOP","slug":"AOP","permalink":"http://persian.gitee.io/blog/tags/AOP/"}]},{"title":"Hello world!","slug":"默认-hello-world","date":"2021-03-03T02:21:48.000Z","updated":"2021-03-04T14:13:54.769Z","comments":false,"path":"article/20213903103925.html","link":"","permalink":"http://persian.gitee.io/blog/article/20213903103925.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"初始化","slug":"初始化","permalink":"http://persian.gitee.io/blog/categories/%E5%88%9D%E5%A7%8B%E5%8C%96/"}],"tags":[{"name":"首页","slug":"首页","permalink":"http://persian.gitee.io/blog/tags/%E9%A6%96%E9%A1%B5/"}]}],"categories":[{"name":"设计原则","slug":"设计原则","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"},{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Java基础","slug":"Java基础","permalink":"http://persian.gitee.io/blog/categories/Java%E5%9F%BA%E7%A1%80/"},{"name":"初始化","slug":"初始化","permalink":"http://persian.gitee.io/blog/categories/%E5%88%9D%E5%A7%8B%E5%8C%96/"}],"tags":[{"name":"设计原则","slug":"设计原则","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"},{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"行为型模式","permalink":"http://persian.gitee.io/blog/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"结构型模式","permalink":"http://persian.gitee.io/blog/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"创建型模式","slug":"创建型模式","permalink":"http://persian.gitee.io/blog/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"spring","slug":"spring","permalink":"http://persian.gitee.io/blog/tags/spring/"},{"name":"bean","slug":"bean","permalink":"http://persian.gitee.io/blog/tags/bean/"},{"name":"基础","slug":"基础","permalink":"http://persian.gitee.io/blog/tags/%E5%9F%BA%E7%A1%80/"},{"name":"集合","slug":"集合","permalink":"http://persian.gitee.io/blog/tags/%E9%9B%86%E5%90%88/"},{"name":"反射","slug":"反射","permalink":"http://persian.gitee.io/blog/tags/%E5%8F%8D%E5%B0%84/"},{"name":"JVM","slug":"JVM","permalink":"http://persian.gitee.io/blog/tags/JVM/"},{"name":"对象创建","slug":"对象创建","permalink":"http://persian.gitee.io/blog/tags/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA/"},{"name":"多线程","slug":"多线程","permalink":"http://persian.gitee.io/blog/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"AOP","slug":"AOP","permalink":"http://persian.gitee.io/blog/tags/AOP/"},{"name":"首页","slug":"首页","permalink":"http://persian.gitee.io/blog/tags/%E9%A6%96%E9%A1%B5/"}]}