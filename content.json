{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://persian.gitee.io/blog","root":"/blog/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-03-03T13:44:07.103Z","updated":"2021-03-03T04:43:19.831Z","comments":false,"path":"/404.html","permalink":"http://persian.gitee.io/blog/404.html","excerpt":"","text":""},{"title":"卢绪亮 de 简历","date":"2021-03-07T13:46:55.159Z","updated":"2021-03-07T13:46:55.159Z","comments":false,"path":"about/index.html","permalink":"http://persian.gitee.io/blog/about/index.html","excerpt":"","text":"电话：15966676035 邮箱：&#49;&#48;&#55;&#x34;&#x31;&#53;&#56;&#x36;&#54;&#x39;&#x40;&#113;&#x71;&#x2e;&#99;&#111;&#109; 地址：滨江区 微信：L15966676035 学历：本科 工作经验：4年 求职意向：Java 开发工程师 期望薪资：面议 自我描述 学习能力强，对新事物的接受力较好，可以很快的适应工作环境，进入工作状态； 有过全栈开发经历，对前后端技术均能熟练使用，搭建了自己的网站； 性格比较温和，与同事间相处均为融洽; 分析能力较好。对将要做的事，先做分析，后想办法实现。 技能 IDE： idea、myeclipse、eclipse前端： JQuery、LayUI、Bootstrap、echarts、JsonMVC框架： Struts1、Struts2、SpringMVC中间件： Dubbo、RocketMq、Redis后端技术： Spring、Spring-security、freemarker、Thymeleaf、Spring-bootORM框架： iBatis、MyBatis、Hibernate数据库： SQLserver、Oracle、Mysql项目管理： SVN、Git其他： 润乾报表、iReport、康虎云报表、Linux部分命令(偏运维) 工作经历德施曼机电(中国)有限公司 java开发工程师 2019.10—2021.04 一家从事智能家居-智能锁具研发制作的公司。就职于该公司的IT部门-Java开发组。项目描述：ERP系统，针对公司的具体业务而搭建的一套企业内部的服务系统，以订单中心、发货中心，售后中心，仓储管理等模块为业务核心，财务管理、报表中心、库存查询等模块为系统数据输出中心，采用分布式架构，将核心模块。小嘀管家，德施曼锁具用户等群体使用的一款APP，其具有德施曼智能设备管理，手机开锁，远程监控，亲友访问，陌生人访问，云视频存储等功能。小嘀进货，公司经销商，分销商等群体使用一款APP以及小程序，可以在APP内进行锁具进货，结账，发票，报销等业务。 小嘀助手，一款报表数据分析小程序，可以按照时间，渠道，大区等维度进行数据分析。技术选型： Bootstrap 、Layui 、 SpringBoot 、SpringMVC、Freemarker、Spring-secyrity、Dubbo、RocketMq、Mybatis、Redis、Mysql、Docker、Jenkins、GIT、Maven工作内容：1.负责ERP系统的订单中心、发货中心等模块的开发及维护工作；2.参与系统需求分析与讨论，并负责指定模块代码开发，运用了MVC、三层等主流框架、利用Jquery+Ajax+Json传值，后台处理完后返回Json字符串，前端运用Bootstrap与Layui前端框架使页面更美观；3.负责小嘀管家，小嘀进货，小嘀助手等后台API的文档设计以及功能开发；4.负责其他公司的API接口对接，如各个物流公司的物流API；维尚家具提供锁具注册，激活API；对接智齿语音服务API等； 北京众阳软件有限公司 产品开发组长 2018.03—2019.09 一家从事医疗健康软件服务的公司,公司主营业务是大数据医疗产品。在职期间负责HRP系列产品中护理管控系统的开发以及优化,并担任开发组长。项目描述：该系统为HRP产品的子系统,依托于众阳大数据平台，将医院的数据进行整合处理，然后产品将对医院护理部需要的数据再次整合分析并呈现给客户，目的实现护理部对全院护理业务数据统一把握,灵活的调配下属科室的护理资源的调配，提高护理工作的效率。该产品有：① 员工管理模块、② 护理质量模块、③ 护士长手册模块、④ 护理工作量模块、⑤ 护理不良事件管理、⑥ 护理敏感指标管理等。技术选型： JSP、struts1/springmvc、spring、echarts、ibatis、springboot、redis、oracle、maven、SVN工作内容：1.针对不同医院对类似功能的个性化需求，提出了功能定制的设想，并实践出了较为成熟的解决方案，这样大大的减少了需求变更频率节约了非必要的人力浪费；2.将产品进行了业务上的功能模块划分以及代码分模块(采用mvn的多模块构建)维护升级，通过这样的方式，大大降低了功能代码之间的耦合度，降低了维护成本，并且对新成员培训时，可以分模块培训,加快了新员工对工作的适应。3.为了产品的护理质量模块的业务流程形成闭环，采取使用微信公众号平台实现消息的通知(采用springboot搭建消息中转平台，redis进行用户数据的缓存，用户关系数据的缓存)；4.为了更快的，及时有效的将数据展示给职能部门(护理部)，采用了实时电视屏的形式(echarts进行数据渲染)将业务数据进行展示，方便职能部门进行资源调配； 北京东华厚盾软件有限公司 Java开发工程师 2017.03—2018.03 一家从事医疗健康软件服务的公司,公司主营业务是大数据医疗产品。在职期间负责HRP系列产品中护理管控系统的开发以及优化,并担任开发组长。项目描述：该系统为HRP产品的子系统,依托于众阳大数据平台，将医院的数据进行整合处理，然后产品将对医院护理部需要的数据再次整合分析并呈现给客户，目的实现护理部对全院护理业务数据统一把握,灵活的调配下属科室的护理资源的调配，提高护理工作的效率。该产品有：① 员工管理模块、② 护理质量模块、③ 护士长手册模块、④ 护理工作量模块、⑤ 护理不良事件管理、⑥ 护理敏感指标管理等。技术选型： JSP、struts1/springmvc、spring、echarts、ibatis、springboot、redis、oracle、maven、SVN工作内容：1.针对不同医院对类似功能的个性化需求，提出了功能定制的设想，并实践出了较为成熟的解决方案，这样大大的减少了需求变更频率节约了非必要的人力浪费；2.将产品进行了业务上的功能模块划分以及代码分模块(采用mvn的多模块构建)维护升级，通过这样的方式，大大降低了功能代码之间的耦合度，降低了维护成本，并且对新成员培训时，可以分模块培训,加快了新员工对工作的适应。3.为了产品的护理质量模块的业务流程形成闭环，采取使用微信公众号平台实现消息的通知(采用springboot搭建消息中转平台，redis进行用户数据的缓存，用户关系数据的缓存)；4.为了更快的，及时有效的将数据展示给职能部门(护理部)，采用了实时电视屏的形式(echarts进行数据渲染)将业务数据进行展示，方便职能部门进行资源调配； 教育经历 山东建筑大学 全日制本科 社交主页 博客：http://persian.gitee.io/blog CSDN: https://blog.csdn.net/weixin_38001682 欢迎关注我的公众号，原创技术文章第一时间推送。"},{"title":"分类","date":"2021-03-03T13:44:07.243Z","updated":"2021-03-03T04:43:19.832Z","comments":false,"path":"categories/index.html","permalink":"http://persian.gitee.io/blog/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-03-03T13:44:07.261Z","updated":"2021-03-03T04:43:19.833Z","comments":false,"path":"tags/index.html","permalink":"http://persian.gitee.io/blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Redis安装","slug":"运维-Redis安装","date":"2021-03-13T06:10:09.619Z","updated":"2021-03-13T11:43:39.976Z","comments":false,"path":"article/20210313194332.html","link":"","permalink":"http://persian.gitee.io/blog/article/20210313194332.html","excerpt":"","text":"一、安装gcc依赖 由于 redis 是用 C 语言开发，安装之前必先确认是否安装 gcc 环境（查询命令gcc -v），如果没有安装，执行以下命令进行安装 1234567891011121314[root@iZwz90a8w2ct7okoo5fqy2Z &#x2F;]# gcc -v Using built-in specs. COLLECT_GCC&#x3D;gcc COLLECT_LTO_WRAPPER&#x3D;&#x2F;usr&#x2F;libexec&#x2F;gcc&#x2F;x86_64-redhat-linux&#x2F;4.8.5&#x2F;lto-wrapper Target: x86_64-redhat-linux Configured with: ..&#x2F;configure --prefix&#x3D;&#x2F;usr --mandir&#x3D;&#x2F;usr&#x2F;share&#x2F;man --infodir&#x3D;&#x2F;usr&#x2F;share&#x2F;info --with-bugurl&#x3D;http:&#x2F;&#x2F;bugzilla.redhat.com&#x2F;bugzilla --enable-bootstrap --enable-shared --enable-threads&#x3D;posix --enable-checking&#x3D;release --with-system-zlib --enable-__cxa_atexit --disable-libunwind-exceptions --enable-gnu-unique-object --enable-linker-build-id --with-linker-hash-style&#x3D;gnu --enable-languages&#x3D;c,c++,objc,obj-c++,java,fortran,ada,go,lto --enable-plugin --enable-initfini-array --disable-libgcj --with-isl&#x3D;&#x2F;builddir&#x2F;build&#x2F;BUILD&#x2F;gcc-4.8.5-20150702&#x2F;obj-x86_64-redhat-linux&#x2F;isl-install --with-cloog&#x3D;&#x2F;builddir&#x2F;build&#x2F;BUILD&#x2F;gcc-4.8.5-20150702&#x2F;obj-x86_64-redhat-linux&#x2F;cloog-install --enable-gnu-indirect-function --with-tune&#x3D;generic --with-arch_32&#x3D;x86-64 --build&#x3D;x86_64-redhat-linux Thread model: posix gcc version 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC) 如上，我的环境时存在的。若没有，执行下面命令[root@iZwz90a8w2ct7okoo5fqy2Z &#x2F;]# yum install -y gcc 二、下载并解压安装包1234567891011121314151617181920212223242526272829303132333435363738[root@iZwz90a8w2ct7okoo5fqy2Z &#x2F;]# wget http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-5.0.3.tar.gz --2021-03-12 10:12:40-- http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-5.0.3.tar.gz Resolving download.redis.io (download.redis.io)... 45.60.125.1 Connecting to download.redis.io (download.redis.io)|45.60.125.1|:80... connected. HTTP request sent, awaiting response... 200 OK Length: 1959445 (1.9M) [application&#x2F;octet-stream] Saving to: ‘redis-5.0.3.tar.gz’ 100%[&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;] 1,959,445 4.14MB&#x2F;s in 0.5s 2021-03-12 10:12:42 (4.14 MB&#x2F;s) - ‘redis-5.0.3.tar.gz’ saved [1959445&#x2F;1959445][root@iZwz90a8w2ct7okoo5fqy2Z &#x2F;]# tar -zxvf redis-5.0.3.tar.gzredis-5.0.3&#x2F;redis-5.0.3&#x2F;.gitignoreredis-5.0.3&#x2F;00-RELEASENOTESredis-5.0.3&#x2F;BUGSredis-5.0.3&#x2F;CONTRIBUTINGredis-5.0.3&#x2F;COPYINGredis-5.0.3&#x2F;INSTALLredis-5.0.3&#x2F;MANIFESTOredis-5.0.3&#x2F;Makefileredis-5.0.3&#x2F;README.mdredis-5.0.3&#x2F;deps&#x2F;redis-5.0.3&#x2F;deps&#x2F;Makefile... 特别多，这里进行忽略...redis-5.0.3&#x2F;utils&#x2F;releasetools&#x2F;redis-5.0.3&#x2F;utils&#x2F;releasetools&#x2F;01_create_tarball.shredis-5.0.3&#x2F;utils&#x2F;releasetools&#x2F;02_upload_tarball.shredis-5.0.3&#x2F;utils&#x2F;releasetools&#x2F;03_test_release.shredis-5.0.3&#x2F;utils&#x2F;releasetools&#x2F;04_release_hash.shredis-5.0.3&#x2F;utils&#x2F;releasetools&#x2F;changelog.tclredis-5.0.3&#x2F;utils&#x2F;speed-regression.tclredis-5.0.3&#x2F;utils&#x2F;whatisdoing.sh 可以按照，压缩包，以及解压的包都有了：redis-5.0.3 redis-5.0.3.tar.gz[root@iZwz90a8w2ct7okoo5fqy2Z &#x2F;]# lsbin boot dev etc home lib lib64 lost+found media mnt opt proc redis-5.0.3 redis-5.0.3.tar.gz root run sbin srv sys tmp usr var www 三、cd切换到redis解压目录下，执行编译1234567891011121314151617181920212223242526272829303132[root@iZwz90a8w2ct7okoo5fqy2Z &#x2F;]# cd &#x2F;redis-5.0.3[root@iZwz90a8w2ct7okoo5fqy2Z redis-5.0.3]# ls00-RELEASENOTES BUGS CONTRIBUTING COPYING deps INSTALL Makefile MANIFESTO README.md redis.conf runtest runtest-cluster runtest-sentinel sentinel.conf src tests utils[root@iZwz90a8w2ct7okoo5fqy2Z redis-5.0.3]# makecd src &amp;&amp; make allmake[1]: Entering directory &#96;&#x2F;redis-5.0.3&#x2F;src&#39; CC Makefile.depmake[1]: Leaving directory &#96;&#x2F;redis-5.0.3&#x2F;src&#39;make[1]: Entering directory &#96;&#x2F;redis-5.0.3&#x2F;src&#39;rm -rf redis-server redis-sentinel redis-cli redis-benchmark redis-check-rdb redis-check-aof *.o *.gcda *.gcno *.gcov redis.info lcov-html Makefile.dep dict-benchmark(cd ..&#x2F;deps &amp;&amp; make distclean)make[2]: Entering directory &#96;&#x2F;redis-5.0.3&#x2F;deps&#39;... 这里同样省略很多具体的编译细节... CC listpack.o CC localtime.o CC lolwut.o CC lolwut5.o LINK redis-server INSTALL redis-sentinel CC redis-cli.o LINK redis-cli CC redis-benchmark.o LINK redis-benchmark INSTALL redis-check-rdb INSTALL redis-check-aofHint: It&#39;s a good idea to run &#39;make test&#39; ;)make[1]: Leaving directory &#96;&#x2F;redis-5.0.3&#x2F;src&#39; 四、安装并指定安装目录123456789101112131415161718192021222324[root@iZwz90a8w2ct7okoo5fqy2Z redis-5.0.3]# make install PREFIX&#x3D;&#x2F;usr&#x2F;local&#x2F;rediscd src &amp;&amp; make installmake[1]: Entering directory &#96;&#x2F;redis-5.0.3&#x2F;src&#39; CC Makefile.depmake[1]: Leaving directory &#96;&#x2F;redis-5.0.3&#x2F;src&#39;make[1]: Entering directory &#96;&#x2F;redis-5.0.3&#x2F;src&#39;Hint: It&#39;s a good idea to run &#39;make test&#39; ;) INSTALL install INSTALL install INSTALL install INSTALL install INSTALL installmake[1]: Leaving directory &#96;&#x2F;redis-5.0.3&#x2F;src&#39;# 可以看到，redis-cli redis-server 已经安装到指定目录下了redis-cli:[root@iZwz90a8w2ct7okoo5fqy2Z &#x2F;]# find &#x2F; -name redis-cli&#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis-cli -- 指定安装的目录&#x2F;redis-5.0.3&#x2F;src&#x2F;redis-cli -- 原始目录[root@iZwz90a8w2ct7okoo5fqy2Z &#x2F;]# find &#x2F; -name redis-server&#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis-server -- 指定安装的目录&#x2F;redis-5.0.3&#x2F;src&#x2F;redis-server -- 原始目录 五、启动服务5.1前台启动1234567891011121314151617181920212223242526272829303132[root@iZwz90a8w2ct7okoo5fqy2Z redis]# cd &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;[root@iZwz90a8w2ct7okoo5fqy2Z bin]# lsredis-benchmark redis-check-aof redis-check-rdb redis-cli redis-sentinel redis-server[root@iZwz90a8w2ct7okoo5fqy2Z bin]# .&#x2F;redis-server 6968:C 12 Mar 2021 10:25:51.651 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo6968:C 12 Mar 2021 10:25:51.651 # Redis version&#x3D;5.0.3, bits&#x3D;64, commit&#x3D;00000000, modified&#x3D;0, pid&#x3D;6968, just started6968:C 12 Mar 2021 10:25:51.651 # Warning: no config file specified, using the default config. In order to specify a config file use .&#x2F;redis-server &#x2F;path&#x2F;to&#x2F;redis.conf _._ _.-&#96;&#96;__ &#39;&#39;-._ _.-&#96;&#96; &#96;. &#96;_. &#39;&#39;-._ Redis 5.0.3 (00000000&#x2F;0) 64 bit .-&#96;&#96; .-&#96;&#96;&#96;. &#96;&#96;&#96;\\&#x2F; _.,_ &#39;&#39;-._ ( &#39; , .-&#96; | &#96;, ) Running in standalone mode |&#96;-._&#96;-...-&#96; __...-.&#96;&#96;-._|&#39;&#96; _.-&#39;| Port: 6379 | &#96;-._ &#96;._ &#x2F; _.-&#39; | PID: 6968 &#96;-._ &#96;-._ &#96;-.&#x2F; _.-&#39; _.-&#39; |&#96;-._&#96;-._ &#96;-.__.-&#39; _.-&#39;_.-&#39;| | &#96;-._&#96;-._ _.-&#39;_.-&#39; | http:&#x2F;&#x2F;redis.io &#96;-._ &#96;-._&#96;-.__.-&#39;_.-&#39; _.-&#39; |&#96;-._&#96;-._ &#96;-.__.-&#39; _.-&#39;_.-&#39;| | &#96;-._&#96;-._ _.-&#39;_.-&#39; | &#96;-._ &#96;-._&#96;-.__.-&#39;_.-&#39; _.-&#39; &#96;-._ &#96;-.__.-&#39; _.-&#39; &#96;-._ _.-&#39; &#96;-.__.-&#39; 6968:M 12 Mar 2021 10:25:51.652 # WARNING: The TCP backlog setting of 511 cannot be enforced because &#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn is set to the lower value of 128.6968:M 12 Mar 2021 10:25:51.652 # Server initialized6968:M 12 Mar 2021 10:25:51.652 # WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add &#39;vm.overcommit_memory &#x3D; 1&#39; to &#x2F;etc&#x2F;sysctl.conf and then reboot or run the command &#39;sysctl vm.overcommit_memory&#x3D;1&#39; for this to take effect.6968:M 12 Mar 2021 10:25:51.652 # WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command &#39;echo never &gt; &#x2F;sys&#x2F;kernel&#x2F;mm&#x2F;transparent_hugepage&#x2F;enabled&#39; as root, and add it to your &#x2F;etc&#x2F;rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.6968:M 12 Mar 2021 10:25:51.652 * DB loaded from disk: 0.000 seconds6968:M 12 Mar 2021 10:25:51.652 * Ready to accept connections 然后可以通过相应的工具，进行连接了，这里是没有设置密码的，并且必须保持这个状态，退出后，redis也会被关掉。想要后台运行，看下面操作。 5.2后台启动 从 redis 的源码目录中复制 redis.conf 到 redis 的安装目录 1234567891011121314151617181920212223242526272829303132333435## 先看下源目录在哪里？[root@iZwz90a8w2ct7okoo5fqy2Z bin]# find &#x2F; -name redis.conf&#x2F;redis-5.0.3&#x2F;redis.conf## 再复制到指定目录[root@iZwz90a8w2ct7okoo5fqy2Z bin]# cp &#x2F;redis-5.0.3&#x2F;redis.conf &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin## 再查找一下，看下目标文件是不是在指定目录下了[root@iZwz90a8w2ct7okoo5fqy2Z bin]# find &#x2F; -name redis.conf&#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis.conf -- 指定目录&#x2F;redis-5.0.3&#x2F;redis.conf[root@iZwz90a8w2ct7okoo5fqy2Z bin]# cd &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;[root@iZwz90a8w2ct7okoo5fqy2Z bin]# ls dump.rdb redis-benchmark redis-check-aof redis-check-rdb redis-cli redis.conf redis-sentinel redis-server## 修改 redis.conf 文件，把 daemonize no 改为 daemonize yes[root@iZwz90a8w2ct7okoo5fqy2Z bin]# vim redis.conf ################################# GENERAL ###################################### By default Redis does not run as a daemon. Use &#39;yes&#39; if you need it.# Note that Redis will write a pid file in &#x2F;var&#x2F;run&#x2F;redis.pid when daemonized.daemonize no -- 这里把no 改为yes## 后台启动[root@iZwz90a8w2ct7okoo5fqy2Z bin]# .&#x2F;redis-server redis.conf 7626:C 12 Mar 2021 10:38:59.125 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo7626:C 12 Mar 2021 10:38:59.125 # Redis version&#x3D;5.0.3, bits&#x3D;64, commit&#x3D;00000000, modified&#x3D;0, pid&#x3D;7626, just started7626:C 12 Mar 2021 10:38:59.125 # Configuration loaded## 查看运行状态[root@iZwz90a8w2ct7okoo5fqy2Z bin]# ps -ef | grep redisroot 7627 1 0 10:38 ? 00:00:00 .&#x2F;redis-server 127.0.0.1:6379root 7652 2128 0 10:39 pts&#x2F;2 00:00:00 grep --color&#x3D;auto redis## 停止服务[root@iZwz90a8w2ct7okoo5fqy2Z bin]kill -9 7627 七、将redis添加至linux服务列表，这样以后的启动，就会方便很多 service redis start – 启动 service redis stop – 关闭 具体操作如下 创建服务脚本 sudo vim /etc/init.d/redis 脚本内容如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#! &#x2F;bin&#x2F;sh# chkconfig: - 85 15PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;redis&#x2F;binSERVER&#x3D;redis-serverNAME&#x3D;redisREDIS_DAEMON&#x3D;$PATH&#x2F;$SERVERCONFIGFILE&#x3D;$PATH&#x2F;$NAME.confSCRIPTNAME&#x3D;&#x2F;etc&#x2F;init.d&#x2F;$NAMEset -e[ -x &quot;$REDIS_DAEMON&quot; ] || exit 0do_start() &#123; .$REDIS_DAEMON $CONFIGFILE || echo -n &quot;redis already running&quot;&#125;do_stop() &#123; pids&#x3D;$(ps -ef | grep $&#123;SERVER&#125; |grep -v grep | awk &#39;&#123;print $2&#125;&#39;) for pid in $&#123;pids&#125; do kill -9 $pid done&#125;case &quot;$1&quot; instart)echo -n &quot;Starting $REDIS_DAEMONE&quot;do_startecho &quot;.&quot;;;stop)echo -n &quot;Stopping $REDIS_DAEMON&quot;do_stopecho &quot;.&quot;;;reload|graceful)echo -n &quot;Reloading $CONFIGFILE configuration...&quot;do_stopdo_startecho &quot;.&quot;;;restart)echo -n &quot;Restarting $REDIS_DAEMON&quot;do_stopdo_startecho &quot;.&quot;;;*)echo &quot;Usage: $SCRIPTNAME &#123;start|stop|reload|restart&#125;&quot; &gt;&amp;2exit 3;;esacexit 0 添加服务 chkconfig –add redis 测试 启动 停止 重启 重载 service redis start service redis stop – 暂不能用 service redis restart service redis reload 测试结果- 权限不够 123[root@iZwz90a8w2ct7okoo5fqy2Z &#x2F;]# service redis stop env: &#x2F;etc&#x2F;init.d&#x2F;redis: Permission denied -- chmod a+x &#x2F;etc&#x2F;init.d&#x2F;redis 还可以添加开机自启动 – 看需要添加 chkconfig redis on 踩坑12[root@iZwz90a8w2ct7okoo5fqy2Z bin]# service redis stop env: &#x2F;etc&#x2F;init.d&#x2F;redis: No such file or directory 因为我的/etc/init.d/redis 脚本是在window下，完成后倒入到linux上的，所以会有这样的问题因此执行入下操作，即可。大多是windows下创建的文件，非unix格式，用vim转换一下就好。 vim打开 先 ctrl + c 再输入 :set ff=unix 最后 :wq 保存退出 收尾处理 既然已经安装完了redis，就将下载的压缩包与解压包删除掉 123456789[root@iZwz90a8w2ct7okoo5fqy2Z &#x2F;]# lsbin boot dev etc home lib lib64 lost+found media mnt opt proc redis-5.0.3 redis-5.0.3.tar.gz root run sbin srv sys tmp usr var www[root@iZwz90a8w2ct7okoo5fqy2Z &#x2F;]# rm -rf redis-5.0.3[root@iZwz90a8w2ct7okoo5fqy2Z &#x2F;]# lsbin boot dev etc home lib lib64 lost+found media mnt opt proc redis-5.0.3.tar.gz root run sbin srv sys tmp usr var www[root@iZwz90a8w2ct7okoo5fqy2Z &#x2F;]# rm -rf redis-5.0.3.tar.gz [root@iZwz90a8w2ct7okoo5fqy2Z &#x2F;]# lsbin boot dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var www 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"运维","slug":"运维","permalink":"http://persian.gitee.io/blog/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"运维","slug":"运维","permalink":"http://persian.gitee.io/blog/tags/%E8%BF%90%E7%BB%B4/"},{"name":"centos7","slug":"centos7","permalink":"http://persian.gitee.io/blog/tags/centos7/"},{"name":"中间件安装","slug":"中间件安装","permalink":"http://persian.gitee.io/blog/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AE%89%E8%A3%85/"}]},{"title":"RocketMQ安装","slug":"运维-RocketMQ安装","date":"2021-03-13T06:10:09.619Z","updated":"2021-03-13T14:18:07.689Z","comments":false,"path":"article/20210312095509.html","link":"","permalink":"http://persian.gitee.io/blog/article/20210312095509.html","excerpt":"","text":"前言 官网只有.zip版本，没有.tgz或.tar.gz版本。RocketMQ官网地址 下载安装包 可以在任意目录执行： wget http://archive.apache.org/dist/rocketmq/4.2.0/rocketmq-all-4.2.0-bin-release.zip script1234567891011[root@iZwz90a8w2ct7okoo5fqy2Z /]# wget http://archive.apache.org/dist/rocketmq/4.2.0/rocketmq-all-4.2.0-bin-release.zip--2021-03-12 13:40:46-- http://archive.apache.org/dist/rocketmq/4.2.0/rocketmq-all-4.2.0-bin-release.zipResolving archive.apache.org (archive.apache.org)... 138.201.131.134, 2a01:4f8:172:2ec5::2Connecting to archive.apache.org (archive.apache.org)|138.201.131.134|:80... connected.HTTP request sent, awaiting response... 200 OKLength: 9080492 (8.7M) [application/zip]Saving to: ‘rocketmq-all-4.2.0-bin-release.zip’100%[=======================================================================================================================================================================================================&gt;] 9,080,492 15.2KB/s in 8m 51s 2021-03-12 13:49:38 (16.7 KB/s) - ‘rocketmq-all-4.2.0-bin-release.zip’ saved [9080492/9080492] 解压安装包至指定目录下script12345678910111213141516171819202122232425262728293031323334353637383940414243444546[root@iZwz90a8w2ct7okoo5fqy2Z /]# unzip rocketmq-all-4.2.0-bin-release.zip -d /usr/local/rocketmq-4.2.0-bash: unzip: command not found[root@iZwz90a8w2ct7okoo5fqy2Z /]# yum install unzip zipLoaded plugins: fastestmirrorDetermining fastest mirrors... 这里将细节省略掉...Dependencies Resolved... 这里将细节省略掉...Total download size: 171 kInstalled size: 365 kIs this ok [y/d/N]: yDownloading packages:unzip-6.0-21.el7.x86_64.rpm | 171 kB 00:00:00 Running transaction checkRunning transaction testTransaction test succeededRunning transaction Installing : unzip-6.0-21.el7.x86_64 1/1 Verifying : unzip-6.0-21.el7.x86_64 1/1 Installed: unzip.x86_64 0:6.0-21.el7 Complete![root@iZwz90a8w2ct7okoo5fqy2Z /]# unzip rocketmq-all-4.2.0-bin-release.zip -d /usr/local/rocketmq-4.2.0Archive: rocketmq-all-4.2.0-bin-release.zip creating: /usr/local/rocketmq-4.2.0/conf/ creating: /usr/local/rocketmq-4.2.0/conf/2m-2s-async/ creating: /usr/local/rocketmq-4.2.0/conf/2m-2s-sync/ ... 这里将细节省略掉... inflating: /usr/local/rocketmq-4.2.0/lib/rocketmq-openmessaging-4.2.0.jar inflating: /usr/local/rocketmq-4.2.0/lib/rocketmq-example-4.2.0.jar inflating: /usr/local/rocketmq-4.2.0/lib/rocketmq-common-4.2.0.jar inflating: /usr/local/rocketmq-4.2.0/lib/rocketmq-store-4.2.0.jar inflating: /usr/local/rocketmq-4.2.0/lib/rocketmq-srvutil-4.2.0.jar inflating: /usr/local/rocketmq-4.2.0/lib/commons-cli-1.2.jar inflating: /usr/local/rocketmq-4.2.0/lib/guava-19.0.jar # 看一下有没有解压到指定目录[root@iZwz90a8w2ct7okoo5fqy2Z /]# cd /usr/local/rocketmq-4.2.0/[root@iZwz90a8w2ct7okoo5fqy2Z rocketmq-4.2.0]# lsbenchmark bin conf lib LICENSE NOTICE README.md 此外还有在这个目录下新建一些文件夹： mkdir logs —— 存储RocketMQ日志目录mkdir store —— 存储RocketMQ数据文件目录cd storemkdir commitlog —— 存储RocketMQ消息信息mkdir consumequeue —— 存储消息的索引数据mkdir index —— 存储消息的索引数据 123456789101112131415[root@iZwz90a8w2ct7okoo5fqy2Z rocketmq-4.2.0]# mkdir logs[root@iZwz90a8w2ct7okoo5fqy2Z rocketmq-4.2.0]# lsbenchmark bin conf lib LICENSE logs NOTICE README.md[root@iZwz90a8w2ct7okoo5fqy2Z rocketmq-4.2.0]# mkdir store[root@iZwz90a8w2ct7okoo5fqy2Z rocketmq-4.2.0]# lsbenchmark bin conf lib LICENSE logs NOTICE README.md store[root@iZwz90a8w2ct7okoo5fqy2Z rocketmq-4.2.0]# cd store[root@iZwz90a8w2ct7okoo5fqy2Z store]# pwd&#x2F;usr&#x2F;local&#x2F;rocketmq-4.2.0&#x2F;store[root@iZwz90a8w2ct7okoo5fqy2Z store]# mkdir commitlog[root@iZwz90a8w2ct7okoo5fqy2Z store]# mkdir consumequeue[root@iZwz90a8w2ct7okoo5fqy2Z store]# mkdir index[root@iZwz90a8w2ct7okoo5fqy2Z store]# lscommitlog consumequeue index conf目录配置文件说明 2m-2s-async ： 2主2从异步2m-2s-sync ： 2主2从同步2m-noslave ： 2主没有从 1234567891011[root@iZwz90a8w2ct7okoo5fqy2Z rocketmq-4.2.0]# cd conf&#x2F;[root@iZwz90a8w2ct7okoo5fqy2Z conf]# ls2m-2s-async 2m-2s-sync 2m-noslave broker.conf logback_broker.xml logback_filtersrv.xml logback_namesrv.xml logback_tools.xml## 以2主2从同步内部配置文件为例[root@iZwz90a8w2ct7okoo5fqy2Z conf]# cd 2m-2s-sync&#x2F;[root@iZwz90a8w2ct7okoo5fqy2Z 2m-2s-sync]# lsbroker-a.properties broker-a-s.properties broker-b.properties broker-b-s.propertiesbroker-a.properties broker-b.properties -- 2主的配置文件broker-a-s.properties broker-b-s.properties -- 2从-2主各自的从文件 由于我这里是单机的配置，因此只修改一下broker-a.properties 文件即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162# 集群名称brokerClusterName&#x3D;rocketmq-cluster# broker名字,注意此处不同的配置文件填写的不一样brokerName&#x3D;broker-a# 0 表示Master,&gt;0 表示SlavebrokerId&#x3D;0# nameServer地址,多个地址时用分号分割（这里地址可以是域名，也可以使IP+端口号，看具体的集群环境所定） -- 比如我目前部署MQ的机器的IP 是 192.168.30.32namesrvAddr&#x3D;192.168.30.32:9876# 在发送消息时,自动创建服务器不存在的Topic,默认创建的队列数defaultTopicQueueNums&#x3D;4# 是否允许Broker 自动创建Topic, 建议线下开启, 线上关闭autoCreateTopicEnable&#x3D;true# 是否允许Broker 自动创建订阅组, 建议线下开启, 线上关闭autoCreateSubscriptionGroup&#x3D;true# Broker 对外服务的地址（这个IP地址跟 namesrvAddr 是一致的，可以不设置值，那么将默认使用该机器的内网地址）brokerIP1&#x3D;192.168.30.32 # Broker 对外服务的监听端口 -- 使用阿里云时，这个端口要配置安全组的，范围设置： 10900&#x2F;10999就足够了，如果是 内网环境的listenPort&#x3D;10911 # 删除文件时间点,默认是凌晨4点deleteWhen&#x3D;04# 文件保留时间,默认是48小时fileReservedTime&#x3D;48# commitLog每个文件的大小默认1GmapedFileSizeCommitLog&#x3D;1073741824# ConsumeQueue每个文件默认存30w条, 根据业务情况调整mapedFileSizeConsumeQueue&#x3D;30000# destroyMapedFileIntervalForcibly&#x3D;12000# redeleteHangedFileInterval&#x3D;12000# 检测物理文件磁盘空间diskMaxUsedSpaceRatio&#x3D;88# 存储路径storePathRootDir&#x3D;&#x2F;usr&#x2F;local&#x2F;rocketmq-4.2.0&#x2F;store# commitLog存储路径storePathCommitLog&#x3D;&#x2F;usr&#x2F;local&#x2F;rocketmq-4.2.0&#x2F;store&#x2F;commitlog# 消息队列储存路径storePathConsumeQueue&#x3D;&#x2F;usr&#x2F;local&#x2F;rocketmq-4.2.0&#x2F;store&#x2F;consumequeue# 消息索引粗存路径storePathIndex&#x3D;&#x2F;usr&#x2F;local&#x2F;rocketmq-4.2.0&#x2F;store&#x2F;index# checkpoint 文件储存路径storeCheckpoint&#x3D;&#x2F;usr&#x2F;local&#x2F;rocketmq-4.2.0&#x2F;store&#x2F;checkpoint# abort 文件存储路径abortFile&#x3D;&#x2F;usr&#x2F;local&#x2F;rocketmq-4.2.0&#x2F;store&#x2F;abort# 限制的消息大小maxMessageSize&#x3D;65536# flushCommitLogLeastPages&#x3D;4# flushConsumeQueueLeastPages&#x3D;2# flushCommitLogThoroughInterval&#x3D;10000# flushConsumeQueueThoroughInterval&#x3D;60000# Broker的角色# -ASYNC_MASTER 异步复制Master# -SYNC_MASTER 同步双写Master# -SLAVEbrokerRole&#x3D;ASYNC_MASTER# 刷盘方式# - ASYNC_FLUSH 异步刷盘# - SYNC_FLUSH 同步刷盘flushDiskType&#x3D;ASYNC_FLUSH# checkTransactionMessageEnable&#x3D;false# 发消息线程池数量# sendMessageTreadPoolNums&#x3D;128# 拉消息线程池数量# pullMessageTreadPoolNums&#x3D;128lushDiskType&#x3D;ASYNC_FLUSHH 关于日志文件的存储,默认的存储路径跟我们实际的logs路径一般是不一致的，因此我们需要做一下修改进入conf目录，替换所有xml文件中的${user.home}，保证日志路径正确 12345678910111213sed -i &#39;s#$&#123;user.home&#125;#&#x2F;usr&#x2F;local&#x2F;rocketmq-4.2.0#g&#39; *.xml[root@iZwz90a8w2ct7okoo5fqy2Z rocketmq-4.2.0]# cd conf&#x2F;[root@iZwz90a8w2ct7okoo5fqy2Z conf]# ls2m-2s-async 2m-2s-sync 2m-noslave broker.conf logback_broker.xml logback_filtersrv.xml logback_namesrv.xml logback_tools.xml# 修改前先看一下，里面会有一个这个的描述[root@iZwz90a8w2ct7okoo5fqy2Z conf]# cat logback_broker.xml# 里面会有一个这个的描述 &lt;file&gt;$&#123;user.home&#125;&#x2F;logs&#x2F;rocketmqlogs&#x2F;filtersrv.log&lt;&#x2F;file&gt;# 替换之后再看[root@iZwz90a8w2ct7okoo5fqy2Z conf]# sed -i &#39;s#$&#123;user.home&#125;#&#x2F;usr&#x2F;local&#x2F;rocketmq-4.2.0#g&#39; *.xml[root@iZwz90a8w2ct7okoo5fqy2Z conf]# cat logback_broker.xml# 这里改变了&lt;file&gt;&#x2F;usr&#x2F;local&#x2F;rocketmq-4.2.0&#x2F;logs&#x2F;rocketmqlogs&#x2F;filtersrv_default.log&lt;&#x2F;file&gt; 注意： set -i ‘s#目标字符串#新字符串#g’ 目标文件 （*.表示全部） 修改一下参数 RocketMQ要求内存，至少为1G，而默认的是设置的8G ,所以我这里修改一下，主要我测试机内存也不没这么多 123456789101112[root@iZwz90a8w2ct7okoo5fqy2Z bin]# vim runbroker.sh # JVM Configuration #&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;修改前： JAVA_OPT&#x3D;&quot;$&#123;JAVA_OPT&#125; -server -Xms8g -Xmx8g -Xmn4g&quot;修改后： JAVA_OPT&#x3D;&quot;$&#123;JAVA_OPT&#125; -server -Xms1g -Xmx1g -Xmn1g&quot;[root@iZwz90a8w2ct7okoo5fqy2Z bin]# vim runserver.sh # JVM Configuration#&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;修改前： JAVA_OPT&#x3D;&quot;$&#123;JAVA_OPT&#125; -server -Xms4g -Xmx4g -Xmn2g -XX:MetaspaceSize&#x3D;128m -XX:MaxMetaspaceSize&#x3D;320m&quot;修改后： JAVA_OPT&#x3D;&quot;$&#123;JAVA_OPT&#125; -server -Xms1g -Xmx1g -Xmn1g -XX:MetaspaceSize&#x3D;128m -XX:MaxMetaspaceSize&#x3D;320m&quot; bin目录下启动 先启动 namesrvnohup sh mqnamesrv &amp; 123[root@iZwz90a8w2ct7okoo5fqy2Z bin]# nohup sh mqnamesrv &amp;[1] 30711[root@iZwz90a8w2ct7okoo5fqy2Z bin]# nohup: ignoring input and appending output to ‘nohup.out’ 再启动 broker nohup sh mqbroker -c /usr/local/rocketmq-4.2.0/conf/2m-2s-sync/broker-a.properties &gt; /dev/null 2&gt;&amp;1 &amp; 12[root@iZwz90a8w2ct7okoo5fqy2Z bin]# nohup sh mqbroker -c /usr/local/rocketmq-4.2.0/conf/2m-2s-sync/broker-a.properties &gt; /dev/null 2&gt;&amp;1 &amp;[2] 31806 或者不进入bin目录 先执行 nohup sh /usr/local/rocketmq-4.2.0/bin/mqnamesrv &amp; 再执行 nohup sh /usr/local/rocketmq-4.2.0/bin/mqbroker -c /usr/local/rocketmq-4.2.0/conf/2m-2s-sync/broker-a.properties &gt; /dev/null 2&gt;&amp;1 &amp; 输入 jps 查看进程1234[root@iZwz90a8w2ct7okoo5fqy2Z bin]# jps31633 NamesrvStartup31813 BrokerStartup31864 Jps bin目录下停止服务1234567891011[root@iZwz90a8w2ct7okoo5fqy2Z bin]# sh mqshutdown namesrvThe mqnamesrv(31633) is running...Send shutdown request to mqnamesrv(31633) OK## 这里关闭broker时，是有延迟的[root@iZwz90a8w2ct7okoo5fqy2Z bin]# sh mqshutdown brokerThe mqbroker(31813) is running...Send shutdown request to mqbroker(31813) OK[root@iZwz90a8w2ct7okoo5fqy2Z bin]# jps3695 Jps 或者不进入bin目录 先执行 sh /usr/local/rocketmq-4.2.0/bin/mqshutdown namesrv 再执行 sh /usr/local/rocketmq-4.2.0/bin/mqshutdown broker 清除zip12345678[root@iZwz90a8w2ct7okoo5fqy2Z ~]# cd &#x2F;[root@iZwz90a8w2ct7okoo5fqy2Z &#x2F;]# lsbin boot dev etc home lib lib64 lost+found media mnt opt proc rocketmq-all-4.2.0-bin-release.zip root run sbin srv sys tmp usr var www[root@iZwz90a8w2ct7okoo5fqy2Z &#x2F;]# [root@iZwz90a8w2ct7okoo5fqy2Z &#x2F;]# rm -rf rocketmq-all-4.2.0-bin-release.zip [root@iZwz90a8w2ct7okoo5fqy2Z &#x2F;]# lsbin boot dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var www RocketMq控制台安装 下载源码： https://github.com/apache/rocketmq-externals 找到rocketmq-console， 先编辑一下rocketmq-console里面的application.properties文件，将项目使用的rocketmq.config.namesrvAddr配置上去（或者在项目启动时，以参数的形式配进去） 见上面的文件，我配置的是 namesrvAddr=192.168.30.32:9876 打成jar包，并把jar部署到 RocketMQ安装的这台机器上（因为上面配置的是 内网地址） 当然可以将这个后台监控jar部署到另外的机器，如果脱离同一个局域网了的话，需要把上面的内网IP改为外网的，并做好端口号开放。 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"运维","slug":"运维","permalink":"http://persian.gitee.io/blog/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"运维","slug":"运维","permalink":"http://persian.gitee.io/blog/tags/%E8%BF%90%E7%BB%B4/"},{"name":"centos7","slug":"centos7","permalink":"http://persian.gitee.io/blog/tags/centos7/"},{"name":"中间件安装","slug":"中间件安装","permalink":"http://persian.gitee.io/blog/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AE%89%E8%A3%85/"}]},{"title":"","slug":"A","date":"2021-03-11T14:12:06.043Z","updated":"2021-03-11T14:12:06.043Z","comments":true,"path":"article/undefined.html","link":"","permalink":"http://persian.gitee.io/blog/article/undefined.html","excerpt":"","text":"各种设计模式汇总：http://c.biancheng.net/view/1331.html","categories":[],"tags":[]},{"title":"IO流","slug":"Java基础-IO流","date":"2021-03-11T14:12:06.043Z","updated":"2021-03-11T14:12:06.043Z","comments":false,"path":"article/20210308094343.html","link":"","permalink":"http://persian.gitee.io/blog/article/20210308094343.html","excerpt":"","text":"概念 流： 代表任何有能力产出数据的数据源对象或者是有能力接受数据的接收端对象流的本质： 数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。作用: 为数据源和目的地建立一个输送通道。 Java IO所采用的模型 Java的IO模型设计非常优秀，它使用Decorator(装饰者)模式，按功能划分Stream，可以动态装配这些Stream，以便获得要的功能。 IO流的分类1、按数据流的方向分为 输入流、输出流 此输入、输出是相对于我们写的代码程序而言 输入流： 从别的地方(本地文件，网络上的资源等)获取资源 输入到 我们的程序中 输出流： 从我们的程序中 输出到 别的地方(本地文件)， 将一个字符串保存到本地文件中，就需要使用输出流。 2、按处理数据单位不同分为 字节流、字符流 1字符 = 2字节、1字节(byte) = 8位(bit)、一个汉字占两个字节长度 字节流： 每次读取(写出)一个字节，当传输的资源文件有中文时，就会出现乱码; 字符流： 每次读取(写出)两个字节，有中文时，使用该流就可以正确传输显示中文。 3、按功能不同分为 节点流、处理流 节点流： 以从或向一个特定的地方（节点）读写数据。如FileInputStream; 处理流： 是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写。如BufferedReader。处理流的构造方法总是要带一个其他的流对象做参数。一个流对象经过其他流的多次包装， 4、四个基本的抽象流类型，所有的流都继承这四个 字节流: InputStream OutputStream字符流: Reader Writer 5、关于分类的小结 看上面的几个分类，可能对于初次学io的同学会感觉到有些混乱，那什么时候用字节流，什么时候该用输出流呢？其实非常简单，举一个例子就学会了1、首先自己要知道是选择输入流还是输出流，这就要根据自己的情况而定，如果你想从程序写东西到别的地方，那么就选择输出流，反之用输入流2、然后考虑你传输数据时，是选择使用字节流传输还是字符流，也就是每次传1个字节还是2个字节，有中文肯定就选择字符流了。（详情见1.8）3、前面两步就可以选出一个合适的节点流了，比如字节输入流inputStream，如果要在此基础上增强功能，那么就在处理流中选择一个合适的即可。 字符流的由来：Java中字符是采用Unicode标准，一个字符是16位，即一个字符使用两个字节来表示。为此，JAVA中引入了处理字符的流。因为数据编码的不同，而有了对字符进行高效操作的流对象。本质其实就是基于字节流读取时，去查了指定的码表。 IO流特性 先进先出，最先写入输出流的数据最先被输入流读取到。 顺序存取，可以一个接一个地往流中写入一串字节，读出时也将按写入顺序读取一串字节，不能随机访问中间的数据。（RandomAccessFile可以从文件的任意位置进行存取（输入输出）操作） 只读或只写，每个流只能是输入流或输出流的一种，不能同时具备两个功能，输入流只能进行读操作，对输出流只能进行写操作。在一个数据传输通道中，如果既要写入数据，又要读取数据，则要分别提供两个流。 IO流常用到的五类一接口 在整个Java.io包中最重要的就是5个类和一个接口。5个类指的是File、OutputStream、InputStream、Writer、Reader；一个接口指的是Serializable。掌握了这些IO的核心操作那么对于Java中的IO体系也就有了一个初步的认识了。 详解 File（文件特征与管理）：File类是对文件系统中文件以及文件夹进行封装的对象，可以通过对象的思想来操作文件和文件夹。 File类保存文件或目录的各种元数据信息，包括文件名、文件长度、最后修改时间、是否可读、获取当前文件的路径名，判断指定文件是否存在、获得当前目录中的文件列表，创建、删除文件和目录等方法。 * InputStream（二进制格式操作）：抽象类，基于字节的输入操作，是所有输入流的父类。定义了所有输入流都具有的共同特征。 * OutputStream（二进制格式操作）：抽象类。基于字节的输出操作。是所有输出流的父类。定义了所有输出流都具有的共同特征。 * Reader（文件格式操作）：抽象类，基于字符的输入操作。 Writer（文件格式操作）：抽象类，基于字符的输出操作。 RandomAccessFile（随机文件操作）：一个独立的类，直接继承至Object.它的功能丰富，可以从文件的任意位置进行存取（输入输出）操作。 Java IO流对象输入字节流InputStream ByteArrayInputStream：字节数组输入流，该类的功能就是从字节数组(byte[])中进行以字节为单位的读取，也就是将资源文件都以字节的形式存入到该类中的字节数组中去，我们拿也是从这个字节数组中拿 PipedInputStream：管道字节输入流，它和PipedOutputStream一起使用，能实现多线程间的管道通信 FilterInputStream:装饰者模式中处于装饰者，具体的装饰者都要继承它，所以在该类的子类下都是用来装饰别的流的，也就是处理类。具体装饰者模式在下面会讲解到，到时就明白了 BufferedInputStream：缓冲流，对处理流进行装饰，增强，内部会有一个缓存区，用来存放字节，每次都是将缓存区存满然后发送，而不是一个字节或两个字节这样发送。效率更高 DataInputStream：数据输入流，它是用来装饰其它输入流，它“允许应用程序以与机器无关方式从底层输入流中读取基本 Java 数据类型” FileInputSream：文件输入流。它通常用于对文件进行读取操作 File：对指定目录的文件进行操作，具体可以查看讲解File的博文。注意，该类虽然是在IO包下，但是并不继承自四大基础类。 * ObjectInputStream：对象输入流，用来提供对“基本数据或对象”的持久存储。通俗点讲，也就是能直接传输对象（反序列化中使用） 输出字节流OutputStream OutputStream： 是所有的输出字节流的父类，它是一个抽象类。 ByteArrayOutputStream、FileOutputStream 是两种基本的介质流，它们分别向Byte数组、和本地文件中写入数据。 PipedOutputStream是向与其它线程共用的管道中写入数据； ObjectOutputStream和所有FilterOutputStream的子类都是装饰流(序列化中使用)。 字符输入流Reader Reader: 是所有的输入字符流的父类，它是一个抽象类。 CharReader、StringReader：是两种基本的介质流，它们分别将Char 数组、String中读取数据。 PipedReader：是从与其它线程共用的管道中读取数据。 BufferedReader：很明显就是一个装饰器，它和其子类负责装饰其它Reader 对象。 FilterReader：是所有自定义具体装饰流的父类，其子类PushbackReader 对Reader 对象进行装饰，会增加一个行号。 InputStreamReader: 是一个连接字节流和字符流的桥梁，它将字节流转变为字符流。 FileReader：可以说是一个达到此功能、常用的工具类，在其源代码中明显使用了将FileInputStream 转变为Reader的方法。我们可以从这个类中得到一定的技巧。Reader 中各个类的用途和使用方法基本和InputStream 中的类使用一致。后面会有Reader 与InputStream 的对应关系。 字符输出流Writer Writer：是所有的输出字符流的父类，它是一个抽象类。 CharArrayWriter、StringWriter：是两种基本的介质流，它们分别向Char 数组、String 中写入数据。PipedWriter 是向与其它线程共用的管道中写入数据; BufferedWriter：是一个装饰器为Writer 提供缓冲功能。 PrintWriter：和PrintStream 极其类似，功能和使用也非常相似。 OutputStreamWriter：是OutputStream 到Writer 转换的桥梁，它的子类FileWiter 其实就是一个实现此功能的具体类（具体可以研究一SourceCode）。功能和使用和OutputStream 极其类似，后面会有它们的对应图。 字节流和字符流使用情况：（重要） 字符流和字节流的使用范围： 字节流一般用来处理图像，视频，以及PPT，Word类型的文件。 字符流一般用于处理纯文本类型的文件，如TXT文件等，字节流可以用来处理纯文本文件，但是字符流不能用于处理图像视频等非文本类型的文件。 字符流与字节流转换 转换流的作用，文本文件在硬盘中以字节流的形式存储时，通过InputStreamReader读取后转化为字符流给程序处理，程序处理的字符流通过OutputStreamWriter转换为字节流保存。 转换流的特点 ta是字符流和字节流之间的桥梁 可对读取到的字节数据经过指定编码转换成字符 可对读取到的字符数据经过指定编码转换成字节 何时使用转换流？ 当字节和字符之间有转换动作时； 流操作的数据需要编码或解码时。 具体的对象体现 InputStreamReader:字节到字符的桥梁，将字节流以字符流输入。OutputStreamWriter:字符到字节的桥梁，将字节流以字符流输出。这两个流对象是字符体系中的成员，它们有转换作用，本身又是字符流，所以在构造的时候需要传入字节流对象进来。 字节流和字符流的区别（重点） 字节流没有缓冲区，是直接输出的，而字符流是输出到缓冲区的。 因此在输出时，字节流不调用colse()方法时，信息已经输出了，而字符流只有在调用close()方法关闭缓冲区时，信息才输出。要想字符流在未关闭时输出信息，则需要手动调用flush()方法。 * 读写单位不同：字节流以字节（8bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节。* 处理对象不同：字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据。结论：只要是处理纯文本数据，就优先考虑使用字符流。除此之外都使用字节流。 System类对IO的支持 针对一些频繁的设备交互，Java语言系统预定了3个可以直接使用的流对象，分别是： System.in（标准输入），通常代表键盘输入。 System.out（标准输出）：通常写往显示器。 System.err（标准错误输出）：通常写往显示器。 标准I/O Java程序可通过命令行参数与外界进行简短的信息交换，同时，也规定了与标准输入、输出设备，如键盘、显示器进行信息交换的方式。而通过文件可以与外界进行任意数据形式的信息交换。 处理流BufferedReader，BufferedWriter,BufferedInputStream BufferedOutputsStream，都要包上一层节点流。也就是说处理流是在节点流的基础之上进行的，带有Buffered的流又称为缓冲流，缓冲流处理文件的输入输出的速度是最快的。所以一般缓冲流的使用比较多。 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://persian.gitee.io/blog/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://persian.gitee.io/blog/tags/Java%E5%9F%BA%E7%A1%80/"},{"name":"IO","slug":"IO","permalink":"http://persian.gitee.io/blog/tags/IO/"}]},{"title":"java关键字","slug":"Java基础-java关键字","date":"2021-03-11T14:12:06.043Z","updated":"2021-03-11T14:12:06.043Z","comments":false,"path":"article/20210311095333.html","link":"","permalink":"http://persian.gitee.io/blog/article/20210311095333.html","excerpt":"","text":"概述 ① JAVA的关键字都是小写的② 在JAVA中目前一共有53个关键字：其中由51+2个保留字=53个关键字。 一、JAVA的保留关键字（2个） ① const——常量，常数：用于修改字段或局部变量的声明。② goto——转到：指定跳转到标签，找到标签后，程序将处理从下一行开始的命令。 二、访问修饰符的关键字（3个） public（公有的）：可跨包 protected(受保护的)：当前包内可用 private(私有的)：当前类可用 三、定义类、接口、抽象类和实现接口、继承类的关键字、实例化对象（6个） class(类)：public class A(){}花括号里是已实现的方法体，类名需要与文件名相同 interface(接口)：public interface B(){}花括号里有方法体，但没有实现，方法体句子后面是英文分号;结尾 abstract(声明抽象)：public abstract class C(){}介于类与接口中间，可以有，也可以没有已经实现的方法体 implemenst(实现)：用于类或接口，实现接口public class A interface B(){} extends(继承)：用于类继承类public class A extends D(){} new(创建新对象)：A a=new A();A表示一个类 四、包的关键字（2个） import(引入包的关键字)：当使用某个包的一些类时，仅需要类名，然后使用ctrl+shift+o或者选定类名（类或属性或方法）按住ctrl+单击，即可自动插入类所在的包； package(定义包的关键字)：将所有相关的类放在一个包类以便查找修改等 五、数据类型的关键字（12个） byte(字节型)：8bit short(短整型)：16bit int(整型)：32bit long(长整型)：64bit char(字节型)：16bit boolean(布尔型)：– float(浮点型)：32bit double(双精度)：64bit void(无返回)：public void A(){}其他需要反回的经常与return连用 null(空值) true(真) false(假） 六、条件循环（流程控制）（12个） if(如果) ：if（条件语句｛执行代码｝如果条件语句成立，就开始执行｛｝里面的内容 else(否则，或者) ：常与if连用，用法相同：if(…){…}else{…} while(当什么时候)：while（条件语句）｛执行代码｝ for（满足三个条件时）：for(初始化循环变量；判断条件；循环变量值｛｝ switch(选择结构)：switch(表达式）｛case 常量表达式1：语句1；…case 常量表达式2；语句2；default:语句；｝default就是如果没有匹配的case就执行它，default并不是必须的。case后的语句可以不用大括号。 case(匹配switch的表达式里的结果) ：同上 default(默认)： default就是如果没有匹配的case就执行它， default并不是必须的 do(运行) ：通长与while连用 break(跳出循环)：直接跳出循环，执行循环体后的代码 continue(继续) ： 中断本次循环，并开始下一轮循环 return(返回) ：return 一个返回值类型 instanceof(实例)：一个二元操作符，和==、&gt;、&lt;是同一类的。测试它左边的对象是否是它右边的类的实例，返回boolean类型的数据 七、修饰方法、类、属性和变量（9个） static(静态的)：属性和方法都可以用static修饰，直接使用类名、属性和方法名。只有内部类可以使用static关键字修饰，调用直接使用类名、内部类类名进行调用。static可以独立存在 final(最终的不可被改变)：方法和类都可用final来修饰；final修饰的类是不能被继承的；final修饰的方法是不能被子类重写。常量的定义：final修饰的属性就是常量 super(调用父类的方法)：常见public void paint(Graphics g){super.paint(g);…} this(当前类的父类的对象)：调用当前类中的方法（表示调用这个方法的对象）this.addActionListener(al):等等 native(本地) strictfp(严格，精准) synchronized(线程，同步)：一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块 transient(短暂) volatile(易失) 八、错误处理（5个） catch(处理异常)： ① try+catch 程序流程是：运行到try块中，如果有异常抛出，则转到catch块去处理。然后执行catch块后面的语句 ② try+catch+finally 程序流程是：运行到try块中，如果有异常抛出，则转到catch垮，catch块执行完毕后，执行finally块的代码，再执行finally块后面的代码。如果没有异常抛出，执行完try块，也要去执行finally块的代码。然后执行finally块后面的语句 ③ try+finally 程序流程是：运行到try块中，如果有异常抛出，则转到finally块的代码。 try(捕获异常) finally（有没有异常都执行） throw(抛出一个异常对象)：一些可以导致程序出问题，比如书写错误，逻辑错误或者是api的应用错误等等。为力防止程序的崩溃就要预先检测这些因素，所以java使用了异常这个机制在java中异常是靠“抛出” 也就是英语的“throw”来使用的，意思是如果发现到什么异常的时候就把错误信息“抛出”&gt; throws(声明一个异常可能被抛出)：把异常交给他的上级管理，自己不进行异常处理 九、其他（2个） enum(枚举，列举，型别) assert(断言) 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://persian.gitee.io/blog/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://persian.gitee.io/blog/tags/Java%E5%9F%BA%E7%A1%80/"},{"name":"java关键字","slug":"java关键字","permalink":"http://persian.gitee.io/blog/tags/java%E5%85%B3%E9%94%AE%E5%AD%97/"}]},{"title":"工厂方法模式","slug":"创建型模式-工厂方法模式","date":"2021-03-11T14:12:06.043Z","updated":"2021-03-11T14:12:06.043Z","comments":false,"path":"article/20211405081412.html","link":"","permalink":"http://persian.gitee.io/blog/article/20211405081412.html","excerpt":"","text":"概念 一种常用的类创建型设计模式,此模式的核心精神是封装类中变化的部分，提取其中个性化善变的部分为独立类，通过依赖注入以达到解耦、复用和方便后期维护拓展的目的。它的核心结构有四个角色，分别是：抽象工厂角色、具体工厂角色、抽象产品角色、具体产品角色工厂方法模式(Factory Method pattern)是最典型的模板方法模式(Template Method pattern)应用。 优点 用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程。 灵活性增强，对于新产品的创建，只需多写一个相应的工厂类。 典型的解耦框架。高层模块只需要知道产品的抽象类，无须关心其他实现类，满足迪米特法则、依赖倒置原则和里氏替换原则。 缺点 类的个数容易过多，增加复杂度 增加了系统的抽象性和理解难度 抽象产品只能生产一种产品，此弊端可使用抽象工厂模式解决。 应用场景 客户只知道创建产品的工厂名，而不知道具体的产品名。如 TCL 电视工厂、海信电视工厂等。 创建对象的任务由多个具体子工厂中的某一个完成，而抽象工厂只提供创建产品的接口。 客户不关心创建产品的细节，只关心产品的品牌。 模式结构与实现角色结构 抽象工厂(AbstractFactory)角色：是工厂方法模式的核心，与应用程序无关。任何在模式中创建的对象的工厂类必须实现这个接口。 具体工厂(ConcreteFactory)角色：这是实现抽象工厂接口的具体工厂类，包含与应用程序密切相关的逻辑，并且受到应用程序调用以创建产品对象。 抽象产品(Product)角色：工厂方法模式所创建的对象的超类型，也就是产品对象的共同父类或共同拥有的接口。 具体产品(Concrete Product)角色：这个角色实现了抽象产品角色所定义的接口。某具体产品有专门的具体工厂创建，它们之间往往一一对应。 模式实现 背景： 比如说现在有这么个需求，就是要对面粉进行加工，从而得到馒头、挂面。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//抽象产品(Product)角色/** * 首先无论是做馒头还是挂面，他们都有一个加工方法，可以抽象出来 */public interface MachineApi &#123; //process：加工 material:材料 public void process(String material); &#125;//具体产品/** * 馒头机器 * steamed bun : 馒头 */public class SteamedBunMachine implements MachineApi &#123; @Override public void process(String material) &#123; System.out.println(&quot;我把&quot; + material + &quot;加工成了馒头&quot;); &#125;&#125;/** * 面条机器 * noodle : 面条 */public class NoodleMachine implements MachineApi &#123; @Override public void process(String material) &#123; System.out.println(&quot;我把&quot; + material + &quot;加工成了面条&quot;); &#125;&#125;//抽象工厂public abstract class Factory&#123; /** * 让子类（具体工厂）来实例化具体对象（机器） */ public abstract MachineApi newMachine(); /** * 加工材料 */ public void process(String material)&#123; MachineApi machine = newMachine(); machine.process(material); &#125;&#125;//具体工厂 —— 需要两家工厂，分别生成馒头和面条/** * 馒头工厂 */public class SteamedBunFactory extends Factory&#123; //馒头工厂，只需要提供馒头机器就行 @Override public MachineApi newMachine() &#123; return new SteamedBunMachine(); &#125;&#125;/** * 面条工厂 */public class NoodleFactory extends Factory&#123; //面条工厂，只需要提供面条机器就行 @Override public MachineApi newMachine() &#123; return new NoodleMachine(); &#125;&#125;// 最后,为了完成原始需求 —— 将面粉加工成馒头跟面条 —— 只需要操作工厂即可public class FactoryTest&#123; public static void main(String[] args)&#123; SteamedBunFactory mSteamedBunFactory = new SteamedBunFactory (); mSteamedBunFactory.process(&quot;面粉&quot;);//我把面粉加工成了馒头 &#125;&#125; 总结 其实这个时候，若又增加了一家饼干厂，那么只需要弄一台饼干机器（继承机器），再弄一个饼干厂（继承工厂）就可以了。根本不需要动之前的代码，这个过程唯一变化的就是做馒头和做面条的流程工艺不同，提取其中个性化善变的部分为独立类，通过依赖注入以达到解耦、复用和方便后期维护拓展的目的。 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"创建型模式","slug":"创建型模式","permalink":"http://persian.gitee.io/blog/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"建造者模式","slug":"创建型模式-建造者模式","date":"2021-03-11T14:12:06.043Z","updated":"2021-03-11T14:25:13.577Z","comments":false,"path":"article/20211405081445.html","link":"","permalink":"http://persian.gitee.io/blog/article/20211405081445.html","excerpt":"","text":"概念 指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。 优点 封装性好，构建和表示分离。 扩展性好，各个具体的建造者相互独立，有利于系统的解耦。 客户端不必知道产品内部组成的细节，建造者可以对创建过程逐步细化，而不对其它模块产生任何影响，便于控制细节风险。 缺点 产品的组成部分必须相同，这限制了其使用范围。 如果产品的内部变化复杂，如果产品内部发生变化，则建造者也要同步修改，后期维护成本较大。 模式结构与实现 建造者（Builder）模式由产品、抽象建造者、具体建造者、指挥者等4个要素构成。其中，Director为指挥者/导演类，负责安排已有模块的顺序;然后告诉Builder开始建造,Builder是抽象建造者，规范产品的组建，一般由子类实现；ConcreteBuilder是具体建造者，实现抽象类定义的所有方法，并且返回一个组建好的对象；Product是产品类，通常实现了模板方法模式。 模式结构 指挥者（Director）：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。指挥者类起到封装的作用，避免高层模块深入到建造者内部的实现类。在建造者模式比较庞大时，指挥类可以有多个。 123456public class Director &#123; public void Construct(Builder builder) &#123; builder.BuildPartA(); builder.BuildPartB(); &#125;&#125; 抽象建造者（Builder）：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()。确定产品由两个部件PartA和PartB组成，并声明一个得到产品建造后结果的方法getResult()。 123456public abstract class Builder &#123; public abstract void BuildPartA(); //产品的A部件 public abstract void BuildPartB(); //产品的B部件 public abstract Product getResult(); //获取产品建造后结果&#125; 具体建造者(Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。有几个产品类就有几个具体的建造者，而且这多个产品类具有相同的接口或抽象类。这里给出一个产品类的样例，多个产品类同理。 12345678910111213141516171819public class ConcreteBuilder1 extends Builder &#123; private Product product = new Product(); //设置产品零件 @Override public void BuildPartA() &#123; product.add(&quot;部件A&quot;); &#125; @Override public void BuildPartB() &#123; product.add(&quot;部件B&quot;); &#125; //组建一个产品 @Override public Product getResult() &#123; return product; &#125;&#125; 产品角色（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个零部件。 123456789101112131415161718public class Client &#123; public static void main(String[] args) &#123; Director director = new Director(); Builder builder1 = new ConcreteBuilder1(); Builder builder2 = new ConcreteBuilder2(); //指挥者用ConcreteBuilder1的方法来建造产品 director.Construct(builder1); Product product1 = builder1.getResult(); product1.show(); //指挥者用ConcreteBuilder2的方法来建造产品 director.Construct(builder2); Product product2 = builder2.getResult(); product2.show(); &#125;&#125; 应用 何时使用： 一个基本部件不会变，而其组合经常变化的时候 使用场景： 相同的方法，不同的执行顺序，产生不同的事件结果时。 需要生成的对象具有复杂的内部结构时。 多个部件或零件，都可以装配到一个对象中，但产生的结果又不相同时。 与工厂模式的区别： 建造者模式更关注于零件装配的顺序。 应用实例： KFC的食品制作流程，原料多少克、加热几分钟等都有严格的规定，我们只需点餐即可，无论在哪里点的都是一样的。 去KFC吃汉堡、薯条、炸鸡等，这些单品是不变的，其组合是经常改变的，也就是所谓的“套餐”。 Java中的StringBuilder/StringBuffer。 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"创建型模式","slug":"创建型模式","permalink":"http://persian.gitee.io/blog/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"抽象工厂模式","slug":"创建型模式-抽象工厂模式","date":"2021-03-11T14:12:06.043Z","updated":"2021-03-11T14:12:06.043Z","comments":false,"path":"article/20211505081501.html","link":"","permalink":"http://persian.gitee.io/blog/article/20211505081501.html","excerpt":"","text":"概念 一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。 使用抽象工厂模式一般要满足以下条件。 系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品。 系统一次只可能消费其中某一族产品，即同族的产品一起使用。 优缺点优点 抽象工厂模式除了具有工厂方法模式的优点外，其他主要优点如下： 可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。 当需要产品族时，抽象工厂可以保证客户端始终只使用同一个产品的产品组。 抽象工厂增强了程序的可扩展性，当增加一个新的产品族时，不需要修改原代码，满足开闭原则。 缺点 当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。增加了系统的抽象性和理解难度。 模式的结构与实现 抽象工厂模式同工厂方法模式一样，也是由抽象工厂、具体工厂、抽象产品、具体产品4个要素构成，但抽象工厂中方法个数不同，抽象产品的个数也不同。 模式的结构 抽象工厂（Abstract Factory）： 提供了创建产品的接口，它包含多个创建产品的方法 newProduct()，可以创建多个不同等级的产品。 具体工厂（Concrete Factory）： 主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。 抽象产品（Product）： 定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。 具体产品（ConcreteProduct）： 实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一的关系。 模式的实现1234567891011121314151617// 抽象工厂：提供了产品的生成方法。interface AbstractFactory &#123; public Product1 newProduct1(); public Product2 newProduct2();&#125;// 具体工厂：实现了产品的生成方法。class ConcreteFactory1 implements AbstractFactory &#123; public Product1 newProduct1() &#123; System.out.println(&quot;具体工厂 1 生成--&gt;具体产品 11...&quot;); return new ConcreteProduct11(); &#125; public Product2 newProduct2() &#123; System.out.println(&quot;具体工厂 1 生成--&gt;具体产品 21...&quot;); return new ConcreteProduct21(); &#125;&#125; 模式的应用场景 抽象工厂模式最早的应用是用于创建属于不同操作系统的视窗构件。如 Java 的 AWT 中的 Button 和 Text 等构件在 Windows 和 UNIX 中的本地实现是不同的。 抽象工厂模式通常适用于以下场景： 当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。 系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。 系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。 模式的扩展 抽象工厂模式的扩展有一定的“开闭原则”倾斜性： 当增加一个新的产品族时只需增加一个新的具体工厂，不需要修改原代码，满足开闭原则。 当产品族中需要增加一个新种类的产品时，则所有的工厂类都需要进行修改，不满足开闭原则。另一方面，当系统中只存在一个等级结构的产品时，抽象工厂模式将退化到工厂方法模式。 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"创建型模式","slug":"创建型模式","permalink":"http://persian.gitee.io/blog/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"亨元模式","slug":"结构型模式-亨元模式","date":"2021-03-11T14:12:06.043Z","updated":"2021-03-11T14:12:06.043Z","comments":false,"path":"article/20211505081524.html","link":"","permalink":"http://persian.gitee.io/blog/article/20211505081524.html","excerpt":"","text":"概念 运用共享技术来有效地支持大量细粒度对象的复用。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似类的开销，从而提高系统资源的利用率。享元模式的定义提出了两个要求：细粒度和共享对象。因为要求细粒度，所以不可避免地会使对象数量多且性质相近，此时我们就将这些对象的信息分为两个部分：内部状态和外部状态。 内部状态指对象共享出来的信息，存储在享元信息内部，并且不回随环境的改变而改变； 外部状态指对象得以依赖的一个标记，随环境的改变而改变，不可共享。比如，连接池中的连接对象，保存在连接对象中的用户名、密码、连接URL等信息，在创建对象的时候就设置好了，不会随环境的改变而改变，这些为内部状态。而当每个连接要被回收利用时，我们需要将它标记为可用状态，这些为外部状态。 享元模式的本质是缓存共享对象，降低内存消耗* 优点 相同对象只要保存一份，这降低了系统中对象的数量，从而降低了系统中细粒度对象给内存带来的压力。 缺点 为了使对象可以共享，需要将一些不能共享的状态外部化，这将增加程序的复杂性。 读取享元模式的外部状态会使得运行时间稍微变长。 模式的结构与实现模式的结构 抽象享元角色（Flyweight）： 是所有的具体享元类的基类，为具体享元规范需要实现的公共接口，非享元的外部状态以参数的形式通过方法传入。 具体享元（Concrete Flyweight）角色： 实现抽象享元角色中所规定的接口。 非享元（Unsharable Flyweight)角色： 是不可以共享的外部状态，它以参数的形式注入具体享元的相关方法中。 享元工厂（Flyweight Factory）角色： 负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。 模式的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//测试类public class FlyweightPattern &#123; public static void main(String[] args) &#123; FlyweightFactory factory = new FlyweightFactory(); Flyweight f01 = factory.getFlyweight(&quot;a&quot;); Flyweight f02 = factory.getFlyweight(&quot;a&quot;); Flyweight f03 = factory.getFlyweight(&quot;a&quot;); Flyweight f11 = factory.getFlyweight(&quot;b&quot;); Flyweight f12 = factory.getFlyweight(&quot;b&quot;); f01.operation(new UnsharedConcreteFlyweight(&quot;第1次调用a。&quot;)); f02.operation(new UnsharedConcreteFlyweight(&quot;第2次调用a。&quot;)); f03.operation(new UnsharedConcreteFlyweight(&quot;第3次调用a。&quot;)); f11.operation(new UnsharedConcreteFlyweight(&quot;第1次调用b。&quot;)); f12.operation(new UnsharedConcreteFlyweight(&quot;第2次调用b。&quot;)); &#125;&#125;//非享元角色class UnsharedConcreteFlyweight &#123; private String info; UnsharedConcreteFlyweight(String info) &#123; this.info = info; &#125; public String getInfo() &#123; return info; &#125; public void setInfo(String info) &#123; this.info = info; &#125;&#125;//抽象享元角色interface Flyweight &#123; public void operation(UnsharedConcreteFlyweight state);&#125;//具体享元角色class ConcreteFlyweight implements Flyweight &#123; private String key; ConcreteFlyweight(String key) &#123; this.key = key; System.out.println(&quot;具体享元&quot; + key + &quot;被创建！&quot;); &#125; public void operation(UnsharedConcreteFlyweight outState) &#123; System.out.print(&quot;具体享元&quot; + key + &quot;被调用，&quot;); System.out.println(&quot;非享元信息是:&quot; + outState.getInfo()); &#125;&#125;//享元工厂角色class FlyweightFactory &#123; private HashMap&lt;String, Flyweight&gt; flyweights = new HashMap&lt;String, Flyweight&gt;(); public Flyweight getFlyweight(String key) &#123; Flyweight flyweight = (Flyweight) flyweights.get(key); if (flyweight != null) &#123; System.out.println(&quot;具体享元&quot; + key + &quot;已经存在，被成功获取！&quot;); &#125; else &#123; flyweight = new ConcreteFlyweight(key); flyweights.put(key, flyweight); &#125; return flyweight; &#125;&#125; 应用场景 当系统中多处需要同一组信息时，可以把这些信息封装到一个对象中，然后对该对象进行缓存，这样，一个对象就可以提供给多出需要使用的地方，避免大量同一对象的多次创建，降低大量内存空间的消耗。享元模式其实是工厂方法模式的一个改进机制，享元模式同样要求创建一个或一组对象，并且就是通过工厂方法模式生成对象的，只不过享元模式为工厂方法模式增加了缓存这一功能。 前面分析了享元模式的结构与特点，下面分析它适用的应用场景。享元模式是通过减少内存中对象的数量来节省内存空间的，所以以下几种情形适合采用享元模式。 系统中存在大量相同或相似的对象，这些对象耗费大量的内存资源。 大部分的对象可以按照内部状态进行分组，且可将不同部分外部化，这样每一个组只需保存一个内部状态。 由于享元模式需要额外维护一个保存享元的数据结构，所以应当在有足够多的享元实例时才值得使用享元模式。 享元模式的扩展 在前面介绍的享元模式中，其结构图通常包含可以共享的部分和不可以共享的部分。在实际使用过程中，有时候会稍加改变，即存在两种特殊的享元模式：单纯享元模式和复合享元模式，下面分别对它们进行简单介绍。 单纯享元模式：这种享元模式中的所有的具体享元类都是可以共享的，不存在非共享的具体享元类。 复合享元模式：这种享元模式中的有些享元对象是由一些单纯享元对象组合而成的，它们就是复合享元对象。虽然复合享元对象本身不能共享，但它们可以分解成单纯享元对象再被共享。 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"结构型模式","permalink":"http://persian.gitee.io/blog/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"外观模式","slug":"结构型模式-外观模式","date":"2021-03-11T14:12:06.043Z","updated":"2021-03-11T14:12:06.043Z","comments":false,"path":"article/20211705081715.html","link":"","permalink":"http://persian.gitee.io/blog/article/20211705081715.html","excerpt":"","text":"概念 外观（Facade）模式又叫作门面模式，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。在日常编码工作中，我们都在有意无意的大量使用外观模式。只要是高层模块需要调度多个子系统（2个以上的类对象），我们都会自觉地创建一个新的类封装这些子系统，提供精简的接口，让高层模块可以更加容易地间接调用这些子系统的功能。尤其是现阶段各种第三方SDK、开源类库，很大概率都会使用外观模式。 优点 外观（Facade）模式是“迪米特法则”的典型应用，它有以下主要优点： 降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。 对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。 降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象。 缺点 不能很好地限制客户使用子系统类，很容易带来未知风险。 增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。 模式的结构与实现 外观（Facade）模式的结构比较简单，主要是定义了一个高层接口。它包含了对各个子系统的引用，客户端可以通过它访问各个子系统的功能。现在来分析其基本结构和实现方法。 模式的结构 外观（Facade）角色： 为多个子系统对外提供一个共同的接口。 子系统（Sub System）角色： 实现系统的部分功能，客户可以通过外观角色访问它。 客户（Client）角色： 通过一个外观角色访问各个子系统的功能。 模式的实现1234567891011121314151617181920212223242526272829303132333435363738394041// 测试类public class FacadePattern &#123; public static void main(String[] args) &#123; Facade f = new Facade(); f.method(); &#125;&#125;//外观角色class Facade &#123; private SubSystem01 obj1 = new SubSystem01(); private SubSystem02 obj2 = new SubSystem02(); private SubSystem03 obj3 = new SubSystem03(); public void method() &#123; obj1.method1(); obj2.method2(); obj3.method3(); &#125;&#125;//子系统角色class SubSystem01 &#123; public void method1() &#123; System.out.println(&quot;子系统01的method1()被调用！&quot;); &#125;&#125;//子系统角色class SubSystem02 &#123; public void method2() &#123; System.out.println(&quot;子系统02的method2()被调用！&quot;); &#125;&#125;//子系统角色class SubSystem03 &#123; public void method3() &#123; System.out.println(&quot;子系统03的method3()被调用！&quot;); &#125;&#125; 应用场景 通常在以下情况下可以考虑使用外观模式。 对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。 当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问。 当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性。 外观模式的扩展 在外观模式中，当增加或移除子系统时需要修改外观类，这违背了“开闭原则”。如果引入抽象外观类，则在一定程度上解决了该问题。 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"结构型模式","permalink":"http://persian.gitee.io/blog/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"桥接模式","slug":"结构型模式-桥接模式","date":"2021-03-11T14:12:06.043Z","updated":"2021-03-11T14:12:06.043Z","comments":false,"path":"article/20211705081738.html","link":"","permalink":"http://persian.gitee.io/blog/article/20211705081738.html","excerpt":"","text":"概念 定义：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。通过上面的描述，我们能很好的感觉到桥接模式遵循了里氏替换原则和依赖倒置原则，最终实现了开闭原则，对修改关闭，对扩展开放。 优点 抽象与实现分离，扩展能力强； 符合开闭原则； 符合合成复用原则； 其实现细节对客户透明； 缺点 由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，能正确地识别出系统中两个独立变化的维度，这增加了系统的理解与设计难度。 模式的结构与实现 可以将抽象化部分与实现化部分分开，取消二者的继承关系，改用组合关系。 模式的结构 抽象化（Abstraction）角色： 定义抽象类，并包含一个对实现化对象的引用。 扩展抽象化（Refined Abstraction）角色： 是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。 实现化（Implementor）角色： 定义实现化角色的接口，供扩展抽象化角色调用。 具体实现化（Concrete Implementor）角色： 给出实现化角色接口的具体实现。 模式的实现12345678910111213141516171819202122232425262728293031323334353637383940414243// 测试类public class BridgeTest &#123; public static void main(String[] args) &#123; Implementor imple = new ConcreteImplementorA(); Abstraction abs = new RefinedAbstraction(imple); abs.Operation(); &#125;&#125;//实现化角色interface Implementor &#123; public void OperationImpl();&#125;//具体实现化角色class ConcreteImplementorA implements Implementor &#123; public void OperationImpl() &#123; System.out.println(&quot;具体实现化(Concrete Implementor)角色被访问&quot;); &#125;&#125;//抽象化角色abstract class Abstraction &#123; protected Implementor imple; protected Abstraction(Implementor imple) &#123; this.imple = imple; &#125; public abstract void Operation();&#125;//扩展抽象化角色class RefinedAbstraction extends Abstraction &#123; protected RefinedAbstraction(Implementor imple) &#123; super(imple); &#125; public void Operation() &#123; System.out.println(&quot;扩展抽象化(Refined Abstraction)角色被访问&quot;); imple.OperationImpl(); &#125;&#125; 应用场景 当一个类内部具备两种或多种变化维度时，使用桥接模式可以解耦这些变化的维度，使高层代码架构稳定。桥接模式通常适用于以下场景： 当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。 当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。 当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。桥接模式的一个常见使用场景就是替换继承。我们知道，继承拥有很多优点，比如，抽象、封装、多态等，父类封装共性，子类实现特性。继承可以很好的实现代码复用（封装）的功能，但这也是继承的一大缺点。因为父类拥有的方法，子类也会继承得到，无论子类需不需要，这说明继承具备强侵入性（父类代码侵入子类），同时会导致子类臃肿。因此，在设计模式中，有一个原则为优先使用组合/聚合，而不是继承。 很多时候，我们分不清该使用继承还是组合/聚合或其他方式等，其实可以从现实语义进行思考。因为软件最终还是提供给现实生活中的人使用的，是服务于人类社会的，软件是具备现实场景的。当我们从纯代码角度无法看清问题时，现实角度可能会提供更加开阔的思路。 扩展 在软件开发中，有时桥接（Bridge）模式可与适配器模式联合使用。当桥接（Bridge）模式的实现化角色的接口与现有类的接口不一致时，可以在二者中间定义一个适配器将二者连接起来。 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"结构型模式","permalink":"http://persian.gitee.io/blog/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"组合模式","slug":"结构型模式-组合模式","date":"2021-03-11T14:12:06.043Z","updated":"2021-03-11T14:12:06.043Z","comments":false,"path":"article/20211805081829.html","link":"","permalink":"http://persian.gitee.io/blog/article/20211805081829.html","excerpt":"","text":"概念 定义：有时又叫作整体-部分（Part-Whole）模式，它是一种将对象组合成树状的层次结构的模式，用来表示“整体-部分”的关系，使用户对单个对象和组合对象具有一致的访问性，属于结构型设计模式。组合模式一般用来描述整体与部分的关系，它将对象组织到树形结构中，顶层的节点被称为根节点，根节点下面可以包含树枝节点和叶子节点，树枝节点下面又可以包含树枝节点和叶子节点。根节点和树枝节点本质上属于同一种数据类型，可以作为容器使用；而叶子节点与树枝节点在语义上不属于用一种类型。但是在组合模式中，会把树枝节点和叶子节点看作属于同一种数据类型（用统一接口定义），让它们具备一致行为。 这样，在组合模式中，整个树形结构中的对象都属于同一种类型，带来的好处就是用户不需要辨别是树枝节点还是叶子节点，可以直接进行操作，给用户的使用带来极大的便利。 优点 组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码； 更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足“开闭原则”； 缺点 设计较复杂，客户端需要花更多时间理清类之间的层次关系； 不容易限制容器中的构件； 不容易用继承的方法来增加构件的新功能。 模式的结构与实现模式的结构 抽象构件（Component）角色： 它的主要作用是为树叶构件和树枝构件声明公共接口，并实现它们的默认行为。在透明式的组合模式中抽象构件还声明访问和管理子类的接口；在安全式的组合模式中不声明访问和管理子类的接口，管理工作由树枝构件完成。（总的抽象类或接口，定义一些通用的方法，比如新增、删除）； 树叶构件（Leaf）角色： 是组合中的叶节点对象，它没有子节点，用于继承或实现抽象构件。 树枝构件（Composite）角色 / 中间构件： 是组合中的分支节点对象，它有子节点，用于继承和实现抽象构件。它的主要作用是存储和管理子部件，通常包含 Add()、Remove()、GetChild() 等方法。 组合模式分为透明式的组合模式和安全式的组合模式：① 透明方式： 在该方式中，由于抽象构件声明了所有子类中的全部方法，所以客户端无须区别树叶对象和树枝对象，对客户端来说是透明的。 但其缺点是：树叶构件本来没有 Add()、Remove() 及 GetChild() 方法，却要实现它们（空实现或抛异常），这样会带来一些安全性问题。② 安全方式： 在该方式中，将管理子构件的方法移到树枝构件中，抽象构件和树叶构件没有对子对象的管理方法，这样就避免了上一种方式的安全性问题。 但由于叶子和分支有不同的接口，客户端在调用时要知道树叶对象和树枝对象的存在，所以失去了透明性。 模式的实现 下面为透明式的组合模式的实现代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class CompositePattern &#123; public static void main(String[] args) &#123; Component c0 = new Composite(); Component c1 = new Composite(); Component leaf1 = new Leaf(&quot;1&quot;); Component leaf2 = new Leaf(&quot;2&quot;); Component leaf3 = new Leaf(&quot;3&quot;); c0.add(leaf1); c0.add(c1); c1.add(leaf2); c1.add(leaf3); c0.operation(); &#125;&#125;//抽象构件interface Component &#123; public void add(Component c); public void remove(Component c); public Component getChild(int i); public void operation();&#125;//树叶构件class Leaf implements Component &#123; private String name; public Leaf(String name) &#123; this.name = name; &#125; public void add(Component c) &#123; &#125; public void remove(Component c) &#123; &#125; public Component getChild(int i) &#123; return null; &#125; public void operation() &#123; System.out.println(&quot;树叶&quot; + name + &quot;：被访问！&quot;); &#125;&#125;//树枝构件class Composite implements Component &#123; private ArrayList&lt;Component&gt; children = new ArrayList&lt;Component&gt;(); public void add(Component c) &#123; children.add(c); &#125; public void remove(Component c) &#123; children.remove(c); &#125; public Component getChild(int i) &#123; return children.get(i); &#125; public void operation() &#123; for (Object obj : children) &#123; ((Component) obj).operation(); &#125; &#125;&#125; 下面为安全式的组合模式的实现代码：安全式的组合模式与透明式组合模式的实现代码类似，只要对其做简单修改就可以了，代码如下。 12345678910111213141516171819// 首先修改 Component 代码，只保留层次的公共行为。interface Component &#123; public void operation();&#125;// 然后修改客户端代码，将树枝构件类型更改为 Composite 类型，以便获取管理子类操作的方法。public class CompositePattern &#123; public static void main(String[] args) &#123; Composite c0 = new Composite(); Composite c1 = new Composite(); Component leaf1 = new Leaf(&quot;1&quot;); Component leaf2 = new Leaf(&quot;2&quot;); Component leaf3 = new Leaf(&quot;3&quot;); c0.add(leaf1); c0.add(c1); c1.add(leaf2); c1.add(leaf3); c0.operation(); &#125;&#125; 应用场景 在需要表示一个对象整体与部分的层次结构的场合。 要求对用户隐藏组合对象与单个对象的不同，用户可以用统一的接口使用组合结构中的所有对象的场合。 组合模式的扩展 如果对前面介绍的组合模式中的树叶节点和树枝节点进行抽象，也就是说树叶节点和树枝节点还有子节点，这时组合模式就扩展成复杂的组合模式了，如Java AWT/Swing中的简单组件JTextComponent有子类JTextField、JTextArea，容器组件Container也有子类Window、Panel。 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"结构型模式","permalink":"http://persian.gitee.io/blog/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"装饰器模式","slug":"结构型模式-装饰器模式","date":"2021-03-11T14:12:06.043Z","updated":"2021-03-11T14:12:06.043Z","comments":false,"path":"article/20211805081847.html","link":"","permalink":"http://persian.gitee.io/blog/article/20211805081847.html","excerpt":"","text":"概念 定义：指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。通常情况下，扩展一个类的功能会使用继承方式来实现。但继承具有静态特征，耦合度高，并且随着扩展功能的增多，子类会很膨胀。如果使用组合关系来创建一个包装对象（即装饰对象）来包裹真实对象，并在保持真实对象的类结构不变的前提下，为其提供额外的功能，这就是装饰器模式的目标。 优点 装饰器是继承的有力补充，比继承灵活，在不改变原有对象的情况下，动态的给一个对象扩展功能，即插即用。 通过使用不用装饰类及这些装饰类的排列组合，可以实现不同效果。 装饰器模式完全遵守开闭原则。 缺点 装饰器模式会增加许多子类，过度使用会增加程序得复杂性。 模式的结构与实现模式的结构 抽象构件（Component）角色： 定义一个抽象接口以规范准备接收附加责任的对象。 具体构件（ConcreteComponent）角色： 实现抽象构件，通过装饰角色为其添加一些职责。 抽象装饰（Decorator）角色： 继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。 具体装饰（ConcreteDecorator）角色： 实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。 模式的实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 装饰器模式的实现代码如下：public class DecoratorPattern &#123; public static void main(String[] args) &#123; Component p = new ConcreteComponent(); p.operation(); System.out.println(&quot;---------------------------------&quot;); Component d = new ConcreteDecorator(p); d.operation(); &#125;&#125;//抽象构件角色interface Component &#123; public void operation();&#125;//具体构件角色class ConcreteComponent implements Component &#123; public ConcreteComponent() &#123; System.out.println(&quot;创建具体构件角色&quot;); &#125; public void operation() &#123; System.out.println(&quot;调用具体构件角色的方法operation()&quot;); &#125;&#125;//抽象装饰角色class Decorator implements Component &#123; private Component component; public Decorator(Component component) &#123; this.component = component; &#125; public void operation() &#123; component.operation(); &#125;&#125;//具体装饰角色class ConcreteDecorator extends Decorator &#123; public ConcreteDecorator(Component component) &#123; super(component); &#125; public void operation() &#123; super.operation(); addedFunction(); &#125; public void addedFunction() &#123; System.out.println(&quot;为具体构件角色增加额外的功能addedFunction()&quot;); &#125;&#125; 应用场景 当需要给一个现有类添加附加职责，而又不能采用生成子类的方法进行扩充时。例如，该类被隐藏或者该类是终极类或者采用继承方式会产生大量的子类。 当需要通过对现有的一组基本功能进行排列组合而产生非常多的功能时，采用继承关系很难实现，而采用装饰器模式却很好实现。 当对象的功能要求可以动态地添加，也可以再动态地撤销时。 装饰器模式在 Java 语言中的最著名的应用莫过于 Java I/O 标准库的设计了。例如，InputStream 的子类 FilterInputStream，OutputStream 的子类 FilterOutputStream，Reader 的子类 BufferedReader 以及 FilterReader，还有 Writer 的子类 BufferedWriter、FilterWriter 以及 PrintWriter 等，它们都是抽象装饰类。 123&#x2F;&#x2F; 下面代码是为 FileReader 增加缓冲区而采用的装饰类 BufferedReader 的例子：BufferedReader in &#x3D; new BufferedReader(new FileReader(&quot;filename.txt&quot;));String s &#x3D; in.readLine(); 装饰器模式的扩展 装饰器模式所包含的4个角色不是任何时候都要存在的，在有些应用环境下模式是可以简化的，如以下两种情况。① 如果只有一个具体构件而没有抽象构件时，可以让抽象装饰继承具体构件。② 如果只有一个具体装饰时，可以将抽象装饰和具体装饰合并。 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"结构型模式","permalink":"http://persian.gitee.io/blog/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"迪米特法则","slug":"设计原则-迪米特法则（最少知道原则）","date":"2021-03-11T14:12:06.043Z","updated":"2021-03-11T16:23:44.387Z","comments":false,"path":"article/20210805080844.html","link":"","permalink":"http://persian.gitee.io/blog/article/20210805080844.html","excerpt":"","text":"概念 迪米特法则（Law of Demeter，LoD）又叫作最少知识原则（Least Knowledge Principle，LKP)，产生于 1987 年美国东北大学（Northeastern University）的一个名为迪米特（Demeter）的研究项目，由伊恩·荷兰（Ian Holland）提出，被 UML 创始者之一的布奇（Booch）普及，后来又因为在经典著作《程序员修炼之道》（The Pragmatic Programmer）提及而广为人知。 定义：只与你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。 优点 迪米特法则要求限制软件实体之间通信的宽度和深度，正确使用迪米特法则将有以下两个优点。 降低了类之间的耦合度，提高了模块的相对独立性。 由于亲合度降低，从而提高了类的可复用率和系统的扩展性。 缺点 过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低。所以，在釆用迪米特法则时需要反复权衡，确保高内聚和低耦合的同时，保证系统的结构清晰。 实现方法 从迪米特法则的定义和特点可知，它强调以下两点： 从依赖者的角度来说，只依赖应该依赖的对象。 从被依赖者的角度说，只暴露应该暴露的方法。 所以，在运用迪米特法则时要注意以下 6 点。 在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。 在类的结构设计上，尽量降低类成员的访问权限。 在类的设计上，优先考虑将一个类设置成不变类。 在对其他类的引用上，将引用其他对象的次数降到最低。 不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。 谨慎使用序列化（Serializable）功能。 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"设计原则","slug":"设计原则","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"}],"tags":[{"name":"设计原则","slug":"设计原则","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"}]},{"title":"里氏代换原则","slug":"设计原则-里氏替换原则","date":"2021-03-05T13:02:06.599Z","updated":"2021-03-11T16:24:10.353Z","comments":false,"path":"article/20210905080908.html","link":"","permalink":"http://persian.gitee.io/blog/article/20210905080908.html","excerpt":"","text":"概念 Barbara Liskov提出：标准定义：如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1代换o2时，程序P的行为没有变化，那么类型S是类型T的子类型。简单解释：所有引用基类（父类的）地方都可以用子类来替换，且程序不会有任何的异常。但是反过来就不行，所有使用子类的地方则不一定能用基类来替代。举例： 狗是动物，不能说动物是狗，因为可能还有猫。 里氏代换原则约束 子类必须实现父类的抽象方法，但不得重写（覆盖）父类的非抽象（已实现）方法; 子类中可以添加特有方法（父类中不存在),此时则无法在以父类定义的对象中使用该方法，除非在使用的时候强转基类成子类进行调用; 当子类覆盖或实现父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松; 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。 总结：所以我们在运用里氏替换原则的时候，尽量把父类设计为抽象类或者接口，让子类继承父类或者实现接口并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。里氏代换原则是开闭原则的具体实现手段之一。 示例代码12345678910111213141516171819// 抽象基类public abstract class Customer &#123;&#125;// 子类1public class CommonCustomer extends Customer&#123;&#125;// 子类2public class VIPCustomer extends Customer&#123;&#125;// 逻辑在这里实现，只需要传入对应的类型即可public class ResetPassword &#123; // 只需要传入Customer类即可，不管任何类型的Customer类，只要继承自Customer,都可以使用里氏替换原则进行替换，假如有新的类型，我们只需要在配置文件中注入新的类型即可。 public void resetPassword(Customer customer)&#123; &#125;&#125; 里氏替换原则是实现开闭原则不可或缺的手段之一。在本例中，通过传递参数使用基类对象，针对抽象编程，从而满足开闭原则。 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"设计原则","slug":"设计原则","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"}],"tags":[{"name":"设计原则","slug":"设计原则","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"}]},{"title":"接口隔离原则","slug":"设计原则-接口隔离原则","date":"2021-03-05T13:02:06.596Z","updated":"2021-03-11T16:21:02.752Z","comments":false,"path":"article/20210805080815.html","link":"","permalink":"http://persian.gitee.io/blog/article/20210805080815.html","excerpt":"","text":"概念 接口隔离原则的两个定义： 使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口; 类间的依赖关系应该建立在最小的接口上; 概念含义 一个接口代表一个角色，不应该将不同的角色都交给一个接口，因为这样可能会形成一个臃肿的大接口； 特定语言的接口，表示接口仅仅是提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口。 总结：根据接口隔离原则，我们可明白，每个接口都应只承担一种相对独立的角色，不干不该干的事情。 实例 场景： 模拟动物平时的动作，当然也包括人，最初的设计就是一个总接口IAnimal，里面定义动物会有的一些动作。 12345678910111213141516171819202122232425262728293031323334353637383940public interface IAnimal&#123; // 吃饭 void eat(); // 工作 void work(); //飞行 void fly();&#125;public class Tony implements IAnimal&#123; @Override public void eat() &#123; System.out.println(&quot;tony吃&quot;); &#125; @Override public void work() &#123; System.out.println(&quot;tony工作&quot;); &#125; @Override public void fly() &#123; System.out.println(&quot;tony不会飞&quot;); &#125;&#125;public class Bird implements IAnimal&#123; @Override public void eat() &#123; System.out.println(&quot;鸟吃&quot;); &#125; @Override public void work() &#123; System.out.println(&quot;鸟工作&quot;); &#125; @Override public void fly() &#123; System.out.println(&quot;鸟飞&quot;); &#125;&#125; 根据上面的写法发现Tony需要实现飞的接口，这很明显不仅仅是多余，而且不合理，因此需要通过接口隔离原则进行重构。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//抽象动物的行为public interface IAnimal &#123; // 吃饭 void eat(); // 睡觉 void sleep();&#125;// 高级动物人 的行为public interface IAdvancedAnimalBehavior &#123; // 打牌 void playCard(); // 骑车 void byBike();&#125;//低级动物的行为public interface IJuniorAnimalBehavior &#123; // fly void fly();&#125;// 实现高级动物人的共通方法public class AbstractAdvancedAnimal implements IAnimal &#123; @Override public void eat() &#123; System.out.println(&quot;人吃&quot;); &#125; @Override public void sleep() &#123; System.out.println(&quot;人睡&quot;); &#125;&#125;// 实现低级动物人的共通方法public class AbstractJuniorAnimal implements IAnimal &#123; @Override public void eat() &#123; System.out.println(&quot;动物吃&quot;); &#125; @Override public void sleep() &#123; System.out.println(&quot;动物睡&quot;); &#125;&#125;// tonypublic class Tony extends AbstractAdvancedAnimal implements IAdvancedAnimalBehavior &#123; @Override public void playCard() &#123; System.out.println(&quot;tony打牌&quot;); &#125; @Override public void byBike() &#123; System.out.println(&quot;tony骑车&quot;); &#125;&#125;// 鸟public class Bird extends AbstractJuniorAnimal implements IJuniorAnimalBehavior&#123; @Override public void fly() &#123; System.out.println(&quot;鸟飞&quot;); &#125;&#125; 重构之后，首先定义了一个总的动物接口的大类，然后分别使用了两个抽象类（一个是高级动物，一个是低级动物）分别去实现这些公共的方法，实现中可以抛出异常，表明继承此抽象类的类可以选择性的重写，可不重写。之后再定义了两个行为接口表明高级动物和低级动物所特有的，这样使得接口之间完全隔离，动物接口不再糅杂各种各样的角色，当然接口的大小尺度还是要靠经验来调整，不能太小，会造成接口泛滥，也不能太大，会背离接口隔离原则。 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"设计原则","slug":"设计原则","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"}],"tags":[{"name":"设计原则","slug":"设计原则","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"}]},{"title":"开闭原则","slug":"设计原则-开闭原则","date":"2021-03-05T13:02:06.595Z","updated":"2021-03-05T12:08:16.851Z","comments":false,"path":"article/20210705080741.html","link":"","permalink":"http://persian.gitee.io/blog/article/20210705080741.html","excerpt":"","text":"概念 对扩展开放，对修改关闭。即在尽量不修改原有代码的基础上进行扩展。 —— 代理模式是开闭原则的最佳实践。 优势 不影响原有代码逻辑的正确性。只需要测试扩展部分的代码； 可以提高代码的复用性； 可以提高系统的可维护性； 如何使用开闭原则 抽象约束 通过接口或者抽象类约束扩展，对扩展进行边界限定，不允许出现在接口或抽象类中不存在的public方法； 参数类型、引用对象尽量使用接口或者抽象类，而不是实现类；（针对抽象编程） 抽象层尽量保持稳定，一旦确定即不允许修改。 元数据控制模块行为 通俗来说就是通过配置文件来操作数据，spring的控制反转就是一个很典型的例子。 约定优于配置 封装变化 将相同的变化封装到一个接口或者类中 将不同的变化封装到不同的类或者接口中（单一职责的体现） 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"设计原则","slug":"设计原则","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"}],"tags":[{"name":"设计原则","slug":"设计原则","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"}]},{"title":"合成复用原则","slug":"设计原则-合成复用原则","date":"2021-03-05T13:02:06.593Z","updated":"2021-03-11T16:20:33.012Z","comments":false,"path":"article/20210705080708.html","link":"","permalink":"http://persian.gitee.io/blog/article/20210705080708.html","excerpt":"","text":"概念 合成复用原则（Composite Reuse Principle，CRP）又叫组合/聚合复用原则（Composition/Aggregate Reuse Principle，CARP）。它要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。如果要使用继承关系，则必须严格遵循里氏替换原则。合成复用原则同里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范。通过合成复用原则来使一些已有的对象使之成为对象的一部分，一般通过组合/聚合关系来实现，而尽量不要使用继承。因为组合和聚合可以降低类之间的耦合度，而继承会让系统更加复杂，最重要的一点会破坏系统的封装性，因为继承会把基类的实现细节暴露给子类，同时如果基类变化，子类也必须跟着改变，而且耦合度会很高。合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。 重要性 通常类的复用分为继承复用和合成复用两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点。 继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。 子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。 它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。 采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点。 它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。 新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。 复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"设计原则","slug":"设计原则","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"}],"tags":[{"name":"设计原则","slug":"设计原则","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"}]},{"title":"单一职责原则","slug":"设计原则-单一职责原则","date":"2021-03-05T13:02:06.592Z","updated":"2021-03-05T12:08:16.892Z","comments":false,"path":"article/20210605080651.html","link":"","permalink":"http://persian.gitee.io/blog/article/20210605080651.html","excerpt":"","text":"概念 不要存在多于一个导致类变更的原因。通俗的说，即一个类只负责一项职责。 问题举例以及按照原则的处理办法问题由来 类T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。 解决方案 遵循单一职责原则。分别建立两个类T1、T2，使T1完成职责P1功能，T2完成职责P2功能。这样，当修改类T1时，不会使职责P2发生故障风险；同理，当修改T2时，也不会使职责P1发生故障风险。 说到单一职责原则，很多人都会不屑一顾。因为它太简单了。稍有经验的程序员即使从来没有读过设计模式、从来没有听说过单一职责原则，在设计软件时也会自觉的遵守这一重要原则，因为这是常识。在软件编程中，谁也不希望因为修改了一个功能导致其他的功能发生故障。而避免出现这一问题的方法便是遵循单一职责原则。虽然单一职责原则如此简单，并且被认为是常识，但是即便是经验丰富的程序员写出的程序，也会有违背这一原则的代码存在。为什么会出现这种现象呢？因为有职责扩散。所谓职责扩散，就是因为某种原因，职责P被分化为粒度更细的职责P1和P2。 遵循单一职责原的优点 可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多； 提高类的可读性，提高系统的可维护性； 变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响; 需要说明的一点是单一职责原则不只是面向对象编程思想所特有的，只要是模块化的程序设计，都适用单一职责原则。 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"设计原则","slug":"设计原则","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"}],"tags":[{"name":"设计原则","slug":"设计原则","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"}]},{"title":"依赖倒转原则","slug":"设计原则-依赖倒置原则","date":"2021-03-05T13:02:06.590Z","updated":"2021-03-11T16:18:05.325Z","comments":false,"path":"article/20210605080610.html","link":"","permalink":"http://persian.gitee.io/blog/article/20210605080610.html","excerpt":"","text":"概念 依赖倒转原则(Dependency Inversion Principle, DIP)：抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。 通俗的定义有两种: 高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。 抽象不应该依赖于具体实现，具体实现应该依赖于抽象。 启发 在设计程序的时候尽量使用层次高的抽象层类。即使用接口和抽象类进行变量的声明、参数类型声明、方法返回类型声明以及数据类型转换等等。即，要注意一个具体类应该只实现抽象类或者接口中存在的方法，不要给出多余的方法，否则抽象类将无法调用子类增加的方法。我们可以通过配置文件来写入具体类，这样一旦程序行为改变，可直接改变配置文件，而不需要更改程序，重新编译，通过依赖倒转原则来满足开闭原则。 在实现依赖倒转原则时，我们需要针对抽象层编程，而将具体类的对象通过依赖注入(DependencyInjection, DI)的方式注入到其他对象中。依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式有三种：：构造注入、设值注入（Setter注入）、接口注入。 12345678910111213141516171819202122232425// 顶层类，或为接口，或为抽象类public interface IUser&#123;&#125;// 实现类public class UserImpl implements IUser&#123;&#125;// 遵循依赖倒转原则public class Test&#123; // 构造注入 private IUser iuser = new UserImpl(); // setter注入 public void setIUser(UserImpl userImpl)&#123; this.iuser = userImpl; &#125; // 接口注入 public void save(IUser iuser)&#123; &#125;&#125; 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"设计原则","slug":"设计原则","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"}],"tags":[{"name":"设计原则","slug":"设计原则","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"}]},{"title":"迭代器模式","slug":"行为型模式-迭代器模式","date":"2021-03-05T13:02:06.589Z","updated":"2021-03-11T16:17:11.525Z","comments":false,"path":"article/20210305205834.html","link":"","permalink":"http://persian.gitee.io/blog/article/20210305205834.html","excerpt":"","text":"概念 定义：提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。迭代器模式是一种对象行为型模式。迭代器模式是通过将聚合对象的遍历行为分离出来，抽象成迭代器类来实现的，其目的是在不暴露聚合对象的内部结构的情况下，让外部代码透明地访问聚合的内部数据。在日常开发中，我们几乎不会自己写迭代器。除非需要定制一个自己实现的数据结构对应的迭代器，否则，开源框架提供的 API 完全够用。 优点 访问一个聚合对象的内容而无须暴露它的内部表示。 遍历任务交由迭代器完成，这简化了聚合类。 它支持以不同方式遍历一个聚合，甚至可以自定义迭代器的子类以支持新的遍历。 增加新的聚合类和迭代器类都很方便，无须修改原有代码。 封装性良好，为遍历不同的聚合结构提供一个统一的接口。 缺点 增加了类的个数，这在一定程度上增加了系统的复杂性。 模式的结构与实现模式的结构 抽象聚合（Aggregate）角色： 定义存储、添加、删除聚合对象以及创建迭代器对象的接口。 具体聚合（ConcreteAggregate）角色： 实现抽象聚合类，返回一个具体迭代器的实例。 抽象迭代器（Iterator）角色： 定义访问和遍历聚合元素的接口，通常包含 hasNext()、first()、next() 等方法。 具体迭代器（Concretelterator）角色： 实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。 ###模式的实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// 客户端public class IteratorPattern &#123; public static void main(String[] args) &#123; Aggregate ag = new ConcreteAggregate(); ag.add(&quot;中山大学&quot;); ag.add(&quot;华南理工&quot;); ag.add(&quot;韶关学院&quot;); System.out.print(&quot;聚合的内容有：&quot;); Iterator it = ag.getIterator(); while (it.hasNext()) &#123; Object ob = it.next(); System.out.print(ob.toString() + &quot;\\t&quot;); &#125; Object ob = it.first(); System.out.println(&quot;\\nFirst：&quot; + ob.toString()); &#125;&#125;//抽象聚合interface Aggregate &#123; public void add(Object obj); public void remove(Object obj); public Iterator getIterator();&#125;//具体聚合class ConcreteAggregate implements Aggregate &#123; private List&lt;Object&gt; list = new ArrayList&lt;Object&gt;(); public void add(Object obj) &#123; list.add(obj); &#125; public void remove(Object obj) &#123; list.remove(obj); &#125; public Iterator getIterator() &#123; return (new ConcreteIterator(list)); &#125;&#125;//抽象迭代器interface Iterator &#123; Object first(); Object next(); boolean hasNext();&#125;//具体迭代器class ConcreteIterator implements Iterator &#123; private List&lt;Object&gt; list = null; private int index = -1; public ConcreteIterator(List&lt;Object&gt; list) &#123; this.list = list; &#125; public boolean hasNext() &#123; if (index &lt; list.size() - 1) &#123; return true; &#125; else &#123; return false; &#125; &#125; public Object first() &#123; index = 0; Object obj = list.get(index); ; return obj; &#125; public Object next() &#123; Object obj = null; if (this.hasNext()) &#123; obj = list.get(++index); &#125; return obj; &#125;&#125; 应用场景 当需要为聚合对象提供多种遍历方式时。 当需要为遍历不同的聚合结构提供一个统一的接口时。 当访问一个聚合对象的内容而无须暴露其内部细节的表示时。由于聚合与迭代器的关系非常密切，所以大多数语言在实现聚合类时都提供了迭代器类，因此大数情况下使用语言中已有的聚合类的迭代器就已经够了。 模式的扩展 迭代器模式常常与组合模式结合起来使用，在对组合模式中的容器构件进行访问时，经常将迭代器潜藏在组合模式的容器构成类中。当然，也可以构造一个外部迭代器来对容器构件进行访问。 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"行为型模式","permalink":"http://persian.gitee.io/blog/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"责任链模式","slug":"行为型模式-责任链模式","date":"2021-03-05T13:02:06.588Z","updated":"2021-03-11T16:12:15.359Z","comments":false,"path":"article/20210305203603.html","link":"","permalink":"http://persian.gitee.io/blog/article/20210305203603.html","excerpt":"","text":"概念 定义：为了避免请求发送者与多个请求处理者耦合在一起，于是将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。注意：责任链模式也叫职责链模式。在责任链模式中，客户只需要将请求发送到责任链上即可，无须关心请求的处理细节和请求的传递过程，请求会自动进行传递。所以责任链将请求的发送者和请求的处理者解耦了。通常情况下，可以通过数据链表来实现职责链模式的数据结构。 优点 降低了对象之间的耦合度。 该模式使得一个对象无须知道到底是哪一个对象处理其请求以及链的结构，发送者和接收者也无须拥有对方的明确信息。 增强了系统的可扩展性。 可以根据需要增加新的请求处理类，满足开闭原则。 增强了给对象指派职责的灵活性。 当工作流程发生变化，可以动态地改变链内的成员或者调动它们的次序，也可动态地新增或者删除责任。 责任链简化了对象之间的连接。 每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。 责任分担。 每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。 缺点 不能保证每个请求一定被处理。** 由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。 对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。 职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用。 模式的结构与实现模式的结构 抽象处理者（Handler）角色： 定义一个处理请求的接口，包含抽象处理方法和一个后继连接。 具体处理者（Concrete Handler）角色： 实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。 客户类（Client）角色： 创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。责任链模式的本质是解耦请求与处理，让请求在处理链中能进行传递与被处理；理解责任链模式应当理解其模式，而不是其具体实现。责任链模式的独到之处是将其节点处理者组合成了链式结构，并允许节点自身决定是否进行请求处理或转发，相当于让请求流动起来。 模式的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 客户端public class ChainOfResponsibilityPattern &#123; public static void main(String[] args) &#123; //组装责任链 Handler handler1 = new ConcreteHandler1(); Handler handler2 = new ConcreteHandler2(); handler1.setNext(handler2); //提交请求 handler1.handleRequest(&quot;two&quot;); &#125;&#125;//抽象处理者角色abstract class Handler &#123; private Handler next; public void setNext(Handler next) &#123; this.next = next; &#125; public Handler getNext() &#123; return next; &#125; //处理请求的方法 public abstract void handleRequest(String request);&#125;//具体处理者角色1class ConcreteHandler1 extends Handler &#123; public void handleRequest(String request) &#123; if (request.equals(&quot;one&quot;)) &#123; System.out.println(&quot;具体处理者1负责处理该请求！&quot;); &#125; else &#123; if (getNext() != null) &#123; getNext().handleRequest(request); &#125; else &#123; System.out.println(&quot;没有人处理该请求！&quot;); &#125; &#125; &#125;&#125;//具体处理者角色2class ConcreteHandler2 extends Handler &#123; public void handleRequest(String request) &#123; if (request.equals(&quot;two&quot;)) &#123; System.out.println(&quot;具体处理者2负责处理该请求！&quot;); &#125; else &#123; if (getNext() != null) &#123; getNext().handleRequest(request); &#125; else &#123; System.out.println(&quot;没有人处理该请求！&quot;); &#125; &#125; &#125;&#125; 在上面代码中，我们把消息硬编码为 String 类型，而在真实业务中，消息是具备多样性的，可以是 int、String 或者自定义类型。因此，在上面代码的基础上，可以对消息类型进行抽象 Request，增强了消息的兼容性。 应用场景 多个对象可以处理一个请求，但具体由哪个对象处理该请求在运行时自动确定。 可动态指定一组对象处理请求，或添加新的处理者。 需要在不明确指定请求处理者的情况下，向多个处理者中的一个提交请求。 模式的扩展 纯的职责链模式： 一个请求必须被某一个处理者对象所接收，且一个具体处理者对某个请求的处理只能采用以下两种行为之一：自己处理（承担责任）；把责任推给下家处理。 不纯的职责链模式： 允许出现某一个具体处理者对象在承担了请求的一部分责任后又将剩余的责任传给下家的情况，且一个请求可以最终不被任何接收端对象所接收。 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"行为型模式","permalink":"http://persian.gitee.io/blog/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"访问者模式","slug":"行为型模式-访问者模式","date":"2021-03-05T13:02:06.587Z","updated":"2021-03-11T16:04:50.964Z","comments":false,"path":"article/20210305202534.html","link":"","permalink":"http://persian.gitee.io/blog/article/20210305202534.html","excerpt":"","text":"概念 定义：将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。它将对数据的操作与数据结构进行分离，是行为类模式中最复杂的一种模式。访问者（Visitor）模式实现的关键是如何将作用于元素的操作分离出来封装成独立的类。 优点 扩展性好。 能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。 复用性好。 可以通过访问者来定义整个对象结构通用的功能，从而提高系统的复用程度。 灵活性好。 访问者模式将数据结构与作用于结构上的操作解耦，使得操作集合可相对自由地演化而不影响系统的数据结构。 符合单一职责原则。 访问者模式把相关的行为封装在一起，构成一个访问者，使每一个访问者的功能都比较单一。 缺点 增加新的元素类很困难。 在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”。 破坏封装。 访问者模式中具体元素对访问者公布细节，这破坏了对象的封装性。 违反了依赖倒置原则。 访问者模式依赖了具体类，而没有依赖抽象类。 模式的结构与实现模式的结构 抽象访问者（Visitor）角色： 定义一个访问具体元素的接口，为每个具体元素类对应一个访问操作 visit() ，该操作中的参数类型标识了被访问的具体元素。 具体访问者（ConcreteVisitor）角色： 实现抽象访问者角色中声明的各个访问操作，确定访问者访问一个元素时该做什么。 抽象元素（Element）角色： 声明一个包含接受操作 accept() 的接口，被接受的访问者对象作为 accept() 方法的参数。 具体元素（ConcreteElement）角色： 实现抽象元素角色提供的 accept() 操作，其方法体通常都是 visitor.visit(this) ，另外具体元素中可能还包含本身业务逻辑的相关操作。 对象结构（Object Structure）角色： 是一个包含元素角色的容器，提供让访问者对象遍历容器中的所有元素的方法，通常由 List、Set、Map 等聚合类实现。 模式的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// 客户端public class VisitorPattern &#123; public static void main(String[] args) &#123; ObjectStructure os = new ObjectStructure(); os.add(new ConcreteElementA()); os.add(new ConcreteElementB()); Visitor visitor = new ConcreteVisitorA(); os.accept(visitor); System.out.println(&quot;------------------------&quot;); visitor = new ConcreteVisitorB(); os.accept(visitor); &#125;&#125;//抽象访问者interface Visitor &#123; void visit(ConcreteElementA element); void visit(ConcreteElementB element);&#125;//具体访问者A类class ConcreteVisitorA implements Visitor &#123; public void visit(ConcreteElementA element) &#123; System.out.println(&quot;具体访问者A访问--&gt;&quot; + element.operationA()); &#125; public void visit(ConcreteElementB element) &#123; System.out.println(&quot;具体访问者A访问--&gt;&quot; + element.operationB()); &#125;&#125;//具体访问者B类class ConcreteVisitorB implements Visitor &#123; public void visit(ConcreteElementA element) &#123; System.out.println(&quot;具体访问者B访问--&gt;&quot; + element.operationA()); &#125; public void visit(ConcreteElementB element) &#123; System.out.println(&quot;具体访问者B访问--&gt;&quot; + element.operationB()); &#125;&#125;//抽象元素类interface Element &#123; void accept(Visitor visitor);&#125;//具体元素A类class ConcreteElementA implements Element &#123; public void accept(Visitor visitor) &#123; visitor.visit(this); &#125; public String operationA() &#123; return &quot;具体元素A的操作。&quot;; &#125;&#125;//具体元素B类class ConcreteElementB implements Element &#123; public void accept(Visitor visitor) &#123; visitor.visit(this); &#125; public String operationB() &#123; return &quot;具体元素B的操作。&quot;; &#125;&#125;//对象结构角色class ObjectStructure &#123; private List&lt;Element&gt; list = new ArrayList&lt;Element&gt;(); public void accept(Visitor visitor) &#123; Iterator&lt;Element&gt; i = list.iterator(); while (i.hasNext()) &#123; ((Element) i.next()).accept(visitor); &#125; &#125; public void add(Element element) &#123; list.add(element); &#125; public void remove(Element element) &#123; list.remove(element); &#125;&#125; 应用场景 当系统中存在类型数量稳定（固定）的一类数据结构时，可以使用访问者模式方便地实现对该类型所有数据结构的不同操作，而又不会对数据产生任何副作用（脏数据）。简而言之，就是当对集合中的不同类型数据（类型数量稳定）进行多种操作时，使用访问者模式。通常在以下情况可以考虑使用访问者（Visitor）模式。 对象结构相对稳定，但其操作算法经常变化的程序。 对象结构中的对象需要提供多种不同且不相关的操作，而且要避免让这些操作的变化影响对象的结构。 对象结构包含很多类型的对象，希望对这些对象实施一些依赖于其具体类型的操作。 模式的扩展 访问者（Visitor）模式是使用频率较高的一种设计模式，它常常同以下两种设计模式联用。 与“迭代器模式”联用。因为访问者模式中的“对象结构”是一个包含元素角色的容器，当访问者遍历容器中的所有元素时，常常要用迭代器。如【例1】中的对象结构是用 List 实现的，它通过 List 对象的 Iterator() 方法获取迭代器。如果对象结构中的聚合类没有提供迭代器，也可以用迭代器模式自定义一个。 访问者（Visitor）模式同“组合模式”联用。因为访问者（Visitor）模式中的“元素对象”可能是叶子对象或者是容器对象，如果元素对象包含容器对象，就必须用到组合模式。 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"行为型模式","permalink":"http://persian.gitee.io/blog/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"解释器模式","slug":"行为型模式-解释器模式","date":"2021-03-05T13:02:06.586Z","updated":"2021-03-11T15:53:47.987Z","comments":false,"path":"article/20210305200834.html","link":"","permalink":"http://persian.gitee.io/blog/article/20210305200834.html","excerpt":"","text":"概念 定义：给分析对象定义一个语言，并定义该语言的文法表示，再设计一个解析器来解释语言中的句子。也就是说，用编译语言的方式来分析应用中的实例。这种模式实现了文法表达式处理的接口，该接口解释一个特定的上下文。 这里提到的文法和句子的概念同编译原理中的描述相同，“文法”指语言的语法规则，而“句子”是语言集中的元素。例如，汉语中的句子有很多，“我是中国人”是其中的一个句子，可以用一棵语法树来直观地描述语言中的句子。解释器模式常用于对简单语言的编译或分析实例中，为了掌握好它的结构与实现，必须先了解编译原理中的“文法、句子、语法树”等相关概念。 文法： 文法是用于描述语言的语法结构的形式规则。没有规矩不成方圆，例如，有些人认为完美爱情的准则是“相互吸引、感情专一、任何一方都没有恋爱经历”，虽然最后一条准则较苛刻，但任何事情都要有规则，语言也一样，不管它是机器语言还是自然语言，都有它自己的文法规则。例如，中文中的“句子”的文法如下。 1234567〈句子〉::&#x3D;〈主语〉〈谓语〉〈宾语〉〈主语〉::&#x3D;〈代词〉|〈名词〉〈谓语〉::&#x3D;〈动词〉〈宾语〉::&#x3D;〈代词〉|〈名词〉〈代词〉你|我|他〈名词〉7大学生I筱霞I英语〈动词〉::&#x3D;是|学习 注：这里的符号“::=”表示“定义为”的意思，用“〈”和“〉”括住的是非终结符，没有括住的是终结符。 句子： 句子是语言的基本单位，是语言集中的一个元素，它由终结符构成，能由“文法”推导出。例如，上述文法可以推出“我是大学生”，所以它是句子。 语法树： 语法树是句子结构的一种树型表示，它代表了句子的推导结果，它有利于理解句子语法结构的层次。有了以上基础知识，现在来介绍解释器模式的结构就简单了。解释器模式的结构与组合模式相似，不过其包含的组成元素比组合模式多，而且组合模式是对象结构型模式，而解释器模式是类行为型模式。 优点 扩展性好。 由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。 容易实现。 在语法树中的每个表达式节点类都是相似的，所以实现其文法较为容易。 缺点 执行效率较低。 解释器模式中通常使用大量的循环和递归调用，当要解释的句子较复杂时，其运行速度很慢，且代码的调试过程也比较麻烦。 会引起类膨胀。 解释器模式中的每条规则至少需要定义一个类，当包含的文法规则很多时，类的个数将急剧增加，导致系统难以管理与维护。 可应用的场景比较少。 在软件开发中，需要定义语言文法的应用实例非常少，所以这种模式很少被使用到。 模式的结构与实现模式的结构 抽象表达式（Abstract Expression）角色： 定义解释器的接口，约定解释器的解释操作，主要包含解释方法 interpret()。 终结符表达式（Terminal Expression）角色： 是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之相对应。 非终结符表达式（Nonterminal Expression）角色： 也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式。 环境（Context）角色： 通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。 客户端（Client）： 主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法。 模式的实现 解释器模式实现的关键是定义文法规则、设计终结符类与非终结符类、画出结构图，必要时构建语法树，其代码结构如下： 12345678910111213141516171819202122232425262728293031//抽象表达式类interface AbstractExpression &#123; public void interpret(String info); //解释方法&#125;//终结符表达式类class TerminalExpression implements AbstractExpression &#123; public void interpret(String info) &#123; //对终结符表达式的处理 &#125;&#125;//非终结符表达式类class NonterminalExpression implements AbstractExpression &#123; private AbstractExpression exp1; private AbstractExpression exp2; public void interpret(String info) &#123; //非对终结符表达式的处理 &#125;&#125;//环境类class Context &#123; private AbstractExpression exp; public Context() &#123; //数据初始化 &#125; public void operation(String info) &#123; //调用相关表达式类的解释方法 &#125;&#125; 应用场景 当语言的文法较为简单，且执行效率不是关键问题时。 当问题重复出现，且可以用一种简单的语言来进行表达时。 当一个语言需要解释执行，并且语言中的句子可以表示为一个抽象语法树的时候，如 XML 文档解释。注意：解释器模式在实际的软件开发中使用比较少，因为它会引起效率、性能以及维护等问题。如果碰到对表达式的解释，在 Java 中可以用 Expression4J 或 Jep 等来设计。 模式的扩展 在项目开发中，如果要对数据表达式进行分析与计算，无须再用解释器模式进行设计了，Java 提供了以下强大的数学公式解析器：Expression4J、MESP(Math Expression String Parser) 和 Jep 等，它们可以解释一些复杂的文法，功能强大，使用简单。 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"行为型模式","permalink":"http://persian.gitee.io/blog/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"观察者模式","slug":"行为型模式-观察者模式","date":"2021-03-05T13:02:06.584Z","updated":"2021-03-11T15:35:15.534Z","comments":false,"path":"article/20210305205733.html","link":"","permalink":"http://persian.gitee.io/blog/article/20210305205733.html","excerpt":"","text":"概念 定义：指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式，它是对象行为型模式。实现观察者模式时要注意具体目标对象和具体观察者对象之间不能直接调用，否则将使两者之间紧密耦合起来，这违反了面向对象的设计原则。 优点 降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。符合依赖倒置原则。 目标与观察者之间建立了一套触发机制。 缺点 目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。 当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。 模式的结构与实现模式的结构 抽象主题（Subject）角色： 也叫抽象目标类，它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法。 具体主题（Concrete Subject）角色： 也叫具体目标类，它实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。 抽象观察者（Observer）角色： 它是一个抽象类或接口，它包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用。 具体观察者（Concrete Observer）角色： 实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态。 模式的实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 客户端public class ObserverPattern &#123; public static void main(String[] args) &#123; Subject subject = new ConcreteSubject(); Observer obs1 = new ConcreteObserver1(); Observer obs2 = new ConcreteObserver2(); subject.add(obs1); subject.add(obs2); subject.notifyObserver(); &#125;&#125;//抽象目标abstract class Subject &#123; protected List&lt;Observer&gt; observers = new ArrayList&lt;Observer&gt;(); //增加观察者方法 public void add(Observer observer) &#123; observers.add(observer); &#125; //删除观察者方法 public void remove(Observer observer) &#123; observers.remove(observer); &#125; public abstract void notifyObserver(); //通知观察者方法&#125;//具体目标class ConcreteSubject extends Subject &#123; public void notifyObserver() &#123; System.out.println(&quot;具体目标发生改变...&quot;); System.out.println(&quot;--------------&quot;); for (Object obs : observers) &#123; ((Observer) obs).response(); &#125; &#125;&#125;//抽象观察者interface Observer &#123; void response(); //反应&#125;//具体观察者1class ConcreteObserver1 implements Observer &#123; public void response() &#123; System.out.println(&quot;具体观察者1作出反应！&quot;); &#125;&#125;//具体观察者1class ConcreteObserver2 implements Observer &#123; public void response() &#123; System.out.println(&quot;具体观察者2作出反应！&quot;); &#125;&#125; 应用场景 在软件系统中，当系统一方行为依赖另一方行为的变动时，可使用观察者模式松耦合联动双方，使得一方的变动可以通知到感兴趣的另一方对象，从而让另一方对象对此做出响应。通过前面的分析与应用实例可知观察者模式适合以下几种情形。 对象间存在一对多关系，一个对象的状态发生改变会影响其他对象。 当一个抽象模型有两个方面，其中一个方面依赖于另一方面时，可将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。 实现类似广播机制的功能，不需要知道具体收听者，只需分发广播，系统中感兴趣的对象会自动接收该广播。 多层级嵌套使用，形成一种链式触发机制，使得事件具备跨域（跨越两种观察者类型）通知。 模式的扩展 在 Java 中，通过 java.util.Observable 类和 java.util.Observer 接口定义了观察者模式，只要实现它们的子类就可以编写观察者模式实例。 Observable类： Observable 类是抽象目标类，它有一个 Vector 向量，用于保存所有要通知的观察者对象，下面来介绍它最重要的 3 个方法。 void addObserver(Observer o) 方法：用于将新的观察者对象添加到向量中。 void notifyObservers(Object arg) 方法：调用向量中的所有观察者对象的 update() 方法，通知它们数据发生改变。通常越晚加入向量的观察者越先得到通知。 void setChange() 方法：用来设置一个 boolean 类型的内部标志位，注明目标对象发生了变化。当它为真时，notifyObservers() 才会通知观察者。 Observer接口： Observer 接口是抽象观察者，它监视目标对象的变化，当目标对象发生变化时，观察者得到通知，并调用 void update(Observable o,Object arg) 方法，进行相应的工作。 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"行为型模式","permalink":"http://persian.gitee.io/blog/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"策略模式","slug":"行为型模式-策略模式","date":"2021-03-05T13:02:06.583Z","updated":"2021-03-11T15:15:41.705Z","comments":false,"path":"article/20210305204333.html","link":"","permalink":"http://persian.gitee.io/blog/article/20210305204333.html","excerpt":"","text":"概念 定义：该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。策略模式是准备一组算法，并将这组算法封装到一系列的策略类里面，作为一个抽象策略类的子类。策略模式的重心不是如何实现算法，而是如何组织这些算法，从而让程序结构更加灵活，具有更好的维护性和扩展性。 优点 多重条件语句不易维护，而使用策略模式可以避免使用多重条件语句，如 if…else 语句、switch…case 语句。 策略模式提供了一系列的可供重用的算法族，恰当使用继承可以把算法族的公共代码转移到父类里面，从而避免重复的代码。 策略模式可以提供相同行为的不同实现，客户可以根据不同时间或空间要求选择不同的。 策略模式提供了对开闭原则的完美支持，可以在不修改原代码的情况下，灵活增加新算法。 策略模式把算法的使用放到环境类中，而算法的实现移到具体策略类中，实现了二者的分离。 缺点 客户端必须理解所有策略算法的区别，以便适时选择恰当的算法类。 策略模式造成很多的策略类，增加维护难度。 模式的结构与实现模式的结构 抽象策略（Strategy）类： 定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法，一般使用接口或抽象类实现。 具体策略（Concrete Strategy）类： 实现了抽象策略定义的接口，提供具体的算法实现。 环境（Context）类： 持有一个策略类的引用，最终给客户端调用。 模式的实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 客户端public class StrategyPattern &#123; public static void main(String[] args) &#123; Context c = new Context(); Strategy s = new ConcreteStrategyA(); c.setStrategy(s); c.strategyMethod(); System.out.println(&quot;-----------------&quot;); s = new ConcreteStrategyB(); c.setStrategy(s); c.strategyMethod(); &#125;&#125;//抽象策略类interface Strategy &#123; public void strategyMethod(); //策略方法&#125;//具体策略类Aclass ConcreteStrategyA implements Strategy &#123; public void strategyMethod() &#123; System.out.println(&quot;具体策略A的策略方法被访问！&quot;); &#125;&#125;//具体策略类Bclass ConcreteStrategyB implements Strategy &#123; public void strategyMethod() &#123; System.out.println(&quot;具体策略B的策略方法被访问！&quot;); &#125;&#125;//环境类class Context &#123; private Strategy strategy; public Strategy getStrategy() &#123; return strategy; &#125; public void setStrategy(Strategy strategy) &#123; this.strategy = strategy; &#125; public void strategyMethod() &#123; strategy.strategyMethod(); &#125;&#125; 应用场景 策略模式在很多地方用到，如 Java SE 中的容器布局管理就是一个典型的实例，Java SE 中的每个容器都存在多种布局供用户选择。在程序设计中，通常在以下几种情况中使用策略模式较多。 一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。 系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。 系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结构。 多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。 模式的扩展 在一个使用策略模式的系统中，当存在的策略很多时，客户端管理所有策略算法将变得很复杂，如果在环境类中使用策略工厂模式来管理这些策略类将大大减少客户端的工作复杂度。 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"行为型模式","permalink":"http://persian.gitee.io/blog/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"状态模式","slug":"行为型模式-状态模式","date":"2021-03-05T13:02:06.582Z","updated":"2021-03-11T15:10:47.447Z","comments":false,"path":"article/20210305203133.html","link":"","permalink":"http://persian.gitee.io/blog/article/20210305203133.html","excerpt":"","text":"概念 定义：对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。状态模式把受环境改变的对象行为包装在不同的状态对象里，其意图是让一个对象在其内部状态改变的时候，其行为也随之改变。 优点 结构清晰，状态模式将与特定状态相关的行为局部化到一个状态中，并且将不同状态的行为分割开来，满足 “单一职责原则”。 将状态转换显示化，减少对象间的相互依赖。将不同的状态引入独立的对象中会使得状态转换变得更加明确，且减少对象间的相互依赖。 状态类职责明确，有利于程序的扩展。通过定义新的子类很容易地增加新的状态和转换。 缺点 状态模式的使用必然会增加系统的类与对象的个数。 状态模式的结构与实现都较为复杂，如果使用不当会导致程序结构和代码的混乱。 状态模式对开闭原则的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源码，否则无法切换到新增状态，而且修改某个状态类的行为也需要修改对应类的源码。 ##模式的结构与实现 模式的结构 环境类（Context）角色： 也称为上下文，它定义了客户端需要的接口，内部维护一个当前状态，并负责具体状态的切换。 抽象状态（State）角色： 定义一个接口，用以封装环境对象中的特定状态所对应的行为，可以有一个或多个行为。 具体状态（Concrete State）角色： 实现抽象状态所对应的行为，并且在需要的情况下进行状态切换。 模式的实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 客户端public class StatePatternClient &#123; public static void main(String[] args) &#123; Context context = new Context(); //创建环境 context.Handle(); //处理请求 context.Handle(); context.Handle(); context.Handle(); &#125;&#125;//环境类class Context &#123; private State state; //定义环境类的初始状态 public Context() &#123; this.state = new ConcreteStateA(); &#125; //设置新状态 public void setState(State state) &#123; this.state = state; &#125; //读取状态 public State getState() &#123; return (state); &#125; //对请求做处理 public void Handle() &#123; state.Handle(this); &#125;&#125;//抽象状态类abstract class State &#123; public abstract void Handle(Context context);&#125;//具体状态A类class ConcreteStateA extends State &#123; public void Handle(Context context) &#123; System.out.println(&quot;当前状态是 A.&quot;); context.setState(new ConcreteStateB()); &#125;&#125;//具体状态B类class ConcreteStateB extends State &#123; public void Handle(Context context) &#123; System.out.println(&quot;当前状态是 B.&quot;); context.setState(new ConcreteStateA()); &#125;&#125; 应用场景 当一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为时，就可以考虑使用状态模式。 一个操作中含有庞大的分支结构，并且这些分支决定于对象的状态时。 模式的扩展 在有些情况下，可能有多个环境对象需要共享一组状态，这时需要引入享元模式，将这些具体状态对象放在集合中供程序共享。 拓展状态模式与责任链模式的区别 状态模式和责任链模式都能消除 if-else 分支过多的问题。但在某些情况下，状态模式中的状态可以理解为责任，那么在这种情况下，两种模式都可以使用。从定义来看，状态模式强调的是一个对象内在状态的改变，而责任链模式强调的是外部节点对象间的改变。从代码实现上来看，两者最大的区别就是状态模式的各个状态对象知道自己要进入的下一个状态对象，而责任链模式并不清楚其下一个节点处理对象，因为链式组装由客户端负责。 状态模式与策略模式的区别 状态模式和策略模式的UML类图架构几乎完全一样，但两者的应用场景是不一样的。策略模式的多种算法行为择其一都能满足，彼此之间是独立的，用户可自行更换策略算法，而状态模式的各个状态间存在相互关系，彼此之间在一定条件下存在自动切换状态的效果，并且用户无法指定状态，只能设置初始状态。 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"行为型模式","permalink":"http://persian.gitee.io/blog/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"模板方法模式","slug":"行为型模式-模板方法模式","date":"2021-03-05T13:02:06.580Z","updated":"2021-03-11T15:04:23.600Z","comments":false,"path":"article/20210305204532.html","link":"","permalink":"http://persian.gitee.io/blog/article/20210305204532.html","excerpt":"","text":"概念 定义：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。它是一种类行为型模式。模板方法模式需要注意抽象类与具体子类之间的协作。它用到了虚函数的多态性技术以及“不用调用我，让我来调用你”的反向控制技术。 优点 它封装了不变部分，扩展可变部分。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。 它在父类中提取了公共的部分代码，便于代码复用。 部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则。 缺点 对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象，间接地增加了系统实现的复杂度。 父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。 由于继承关系自身的缺点，如果父类添加新的抽象方法，则所有子类都要改一遍。 模式的结构与实现模式的结构 抽象类/抽象模板（Abstract Class）： 抽象模板类，负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。这些方法的定义如下 ① 模板方法： 定义了算法的骨架，按某种顺序调用其包含的基本方法。 ② 基本方法： 是整个算法中的一个步骤，包含以下几种类型。 抽象方法：在抽象类中声明，由具体子类实现。 具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它。 钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。 具体子类/具体实现（Concrete Class）： 具体实现类，实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的一个组成步骤。 模式的实现1234567891011121314151617181920212223242526272829303132333435// 客户端public class TemplateMethodPattern &#123; public static void main(String[] args) &#123; AbstractClass tm = new ConcreteClass(); tm.TemplateMethod(); &#125;&#125;//抽象类abstract class AbstractClass &#123; //模板方法 public void TemplateMethod() &#123; SpecificMethod(); abstractMethod1(); abstractMethod2(); &#125; //具体方法 public void SpecificMethod() &#123; System.out.println(&quot;抽象类中的具体方法被调用...&quot;); &#125; //抽象方法1 public abstract void abstractMethod1(); //抽象方法2 public abstract void abstractMethod2();&#125;//具体子类class ConcreteClass extends AbstractClass &#123; public void abstractMethod1() &#123; System.out.println(&quot;抽象方法1的实现被调用...&quot;); &#125; public void abstractMethod2() &#123; System.out.println(&quot;抽象方法2的实现被调用...&quot;); &#125;&#125; 应用场景 算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。 当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。首先，要识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。 当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进行扩展。 模式的扩展 在模板方法模式中，基本方法包含：抽象方法、具体方法和钩子方法，正确使用 “钩子方法” 可以使得子类控制父类的行为。 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"行为型模式","permalink":"http://persian.gitee.io/blog/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"备忘录模式","slug":"行为型模式-备忘录模式","date":"2021-03-05T13:02:06.579Z","updated":"2021-03-11T14:56:22.832Z","comments":false,"path":"article/20210305201732.html","link":"","permalink":"http://persian.gitee.io/blog/article/20210305201732.html","excerpt":"","text":"概念 定义：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。该模式又叫快照模式。备忘录模式的核心是设计备忘录类以及用于管理备忘录的管理者类。 优点 提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。 实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。 简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则。 缺点 资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。 模式的结构与实现模式的结构 发起人（Originator）角色： 记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。 备忘录（Memento）角色： 负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。 管理者（Caretaker）角色： 对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。 模式的实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 客户端public class MementoPattern &#123; public static void main(String[] args) &#123; Originator or = new Originator(); Caretaker cr = new Caretaker(); or.setState(&quot;S0&quot;); System.out.println(&quot;初始状态:&quot; + or.getState()); cr.setMemento(or.createMemento()); //保存状态 or.setState(&quot;S1&quot;); System.out.println(&quot;新的状态:&quot; + or.getState()); or.restoreMemento(cr.getMemento()); //恢复状态 System.out.println(&quot;恢复状态:&quot; + or.getState()); &#125;&#125;//备忘录class Memento &#123; private String state; public Memento(String state) &#123; this.state = state; &#125; public void setState(String state) &#123; this.state = state; &#125; public String getState() &#123; return state; &#125;&#125;//发起人class Originator &#123; private String state; public void setState(String state) &#123; this.state = state; &#125; public String getState() &#123; return state; &#125; public Memento createMemento() &#123; return new Memento(state); &#125; public void restoreMemento(Memento m) &#123; this.setState(m.getState()); &#125;&#125;//管理者class Caretaker &#123; private Memento memento; public void setMemento(Memento m) &#123; memento = m; &#125; public Memento getMemento() &#123; return memento; &#125;&#125; 应用场景 需要保存与恢复数据的场景，如玩游戏时的中间结果的存档功能。 需要提供一个可回滚操作的场景，如 Word、记事本、Photoshop，Eclipse 等软件在编辑时按 Ctrl+Z 组合键，还有数据库中事务操作。 模式的扩展 备忘录模式与原型模式混合使用。在备忘录模式中，通过定义“备忘录”来备份“发起人”的信息，而原型模式的 clone() 方法具有自备份功能，所以，如果让发起人实现 Cloneable 接口就有备份自己的功能，这时可以删除备忘录类。 另外： Spring Webflow中DefaultMessageContext类实现了StateManageableMessageContext接口，查看其源码可以发现其主要逻辑就相当于给Message备份。 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"行为型模式","permalink":"http://persian.gitee.io/blog/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"命令模式","slug":"行为型模式-命令模式","date":"2021-03-05T13:02:06.578Z","updated":"2021-03-11T14:49:06.842Z","comments":false,"path":"article/20212205082242.html","link":"","permalink":"http://persian.gitee.io/blog/article/20212205082242.html","excerpt":"","text":"概念 定义：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行储存、传递、调用、增加与管理。可以将系统中的相关操作抽象成命令，使调用者与实现者相关分离。 优点 通过引入中间件（抽象接口）降低系统的耦合度。 扩展性良好，增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，且满足“开闭原则”。 可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。 方便实现 Undo 和 Redo 操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复。 可以在现有命令的基础上，增加额外功能。比如日志记录，结合装饰器模式会更加灵活。 缺点 可能产生大量具体的命令类。因为每一个具体操作都需要设计一个具体命令类，这会增加系统的复杂性。 命令模式的结果其实就是接收方的执行结果，但是为了以命令的形式进行架构、解耦请求与实现，引入了额外类型结构（引入了请求方与抽象命令接口），增加了理解上的困难。不过这也是设计模式的通病，抽象必然会额外增加类的数量，代码抽离肯定比代码聚合更加难理解。 模式的结构与实现模式的结构 抽象命令类（Command）角色： 声明执行命令的接口，拥有执行命令的抽象方法 execute()。 具体命令类（Concrete Command）角色： 是抽象命令类的具体实现类，它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作。 实现者/接收者（Receiver）角色： 执行命令功能的相关操作，是具体命令对象业务的真正实现者。 调用者/请求者（Invoker）角色： 是请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者。 模式的实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 客户端public class CommandPattern &#123; public static void main(String[] args) &#123; Command cmd = new ConcreteCommand(); Invoker ir = new Invoker(cmd); System.out.println(&quot;客户访问调用者的call()方法...&quot;); ir.call(); &#125;&#125;//调用者class Invoker &#123; private Command command; public Invoker(Command command) &#123; this.command = command; &#125; public void setCommand(Command command) &#123; this.command = command; &#125; public void call() &#123; System.out.println(&quot;调用者执行命令command...&quot;); command.execute(); &#125;&#125;//抽象命令interface Command &#123; public abstract void execute();&#125;//具体命令class ConcreteCommand implements Command &#123; private Receiver receiver; ConcreteCommand() &#123; receiver = new Receiver(); &#125; public void execute() &#123; receiver.action(); &#125;&#125;//接收者class Receiver &#123; public void action() &#123; System.out.println(&quot;接收者的action()方法被调用...&quot;); &#125;&#125; 应用场景 当系统的某项操作具备命令语义，且命令实现不稳定（变化）时，可以通过命令模式解耦请求与实现。使用抽象命令接口使请求方的代码架构稳定，封装接收方具体命令的实现细节。接收方与抽象命令呈现弱耦合（内部方法无需一致），具备良好的扩展性。 命令模式通常适用于以下场景： 请求调用者需要与请求接收者解耦时，命令模式可以使调用者和接收者不直接交互。 系统随机请求命令或经常增加、删除命令时，命令模式可以方便地实现这些功能。 当系统需要执行一组操作时，命令模式可以定义宏命令来实现该功能。 当系统需要支持命令的撤销（Undo）操作和恢复（Redo）操作时，可以将命令对象存储起来，采用备忘录模式来实现。 模式的扩展 在软件开发中，有时将命令模式与前面学的组合模式联合使用，这就构成了宏命令模式，也叫组合命令模式。宏命令包含了一组命令，它充当了具体命令与调用者的双重角色，执行它时将递归调用它所包含的所有命令。 令模式与备忘录（Memento）模式组合使用，这样就变成了可撤销的命令模式。 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"行为型模式","permalink":"http://persian.gitee.io/blog/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"中介者模式","slug":"行为型模式-中介者模式","date":"2021-03-05T13:02:06.576Z","updated":"2021-03-11T14:41:10.422Z","comments":false,"path":"article/20212205082219.html","link":"","permalink":"http://persian.gitee.io/blog/article/20212205082219.html","excerpt":"","text":"概念 定义：定义一个中介对象来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。中介者模式又叫调停模式，它是迪米特法则的典型应用。中介者模式实现的关键是找出 “中介者”。 优点 类之间各司其职，符合迪米特法则。 降低了对象之间的耦合性，使得对象易于独立地被复用。 将对象间的一对多关联转变为一对一的关联，提高系统的灵活性，使得系统易于维护和扩展。 缺点 中介者模式将原本多个对象直接的相互依赖变成了中介者和多个同事类的依赖关系。当同事类越多时，中介者就会越臃肿，变得复杂且难以维护。 模式的结构与实现模式的结构 抽象中介者（Mediator）角色： 它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。 具体中介者（Concrete Mediator）角色： 实现中介者接口，定义一个 List 来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色。 抽象同事类（Colleague）角色： 定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。 具体同事类（Concrete Colleague）角色： 是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。 模式的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class MediatorPattern &#123; public static void main(String[] args) &#123; Mediator md = new ConcreteMediator(); Colleague c1, c2; c1 = new ConcreteColleague1(); c2 = new ConcreteColleague2(); md.register(c1); md.register(c2); c1.send(); System.out.println(&quot;-------------&quot;); c2.send(); &#125;&#125;//抽象中介者abstract class Mediator &#123; public abstract void register(Colleague colleague); public abstract void relay(Colleague cl); //转发&#125;//具体中介者class ConcreteMediator extends Mediator &#123; private List&lt;Colleague&gt; colleagues = new ArrayList&lt;Colleague&gt;(); public void register(Colleague colleague) &#123; if (!colleagues.contains(colleague)) &#123; colleagues.add(colleague); colleague.setMedium(this); &#125; &#125; public void relay(Colleague cl) &#123; for (Colleague ob : colleagues) &#123; if (!ob.equals(cl)) &#123; ((Colleague) ob).receive(); &#125; &#125; &#125;&#125;//抽象同事类abstract class Colleague &#123; protected Mediator mediator; public void setMedium(Mediator mediator) &#123; this.mediator = mediator; &#125; public abstract void receive(); public abstract void send();&#125;//具体同事类class ConcreteColleague1 extends Colleague &#123; public void receive() &#123; System.out.println(&quot;具体同事类1收到请求。&quot;); &#125; public void send() &#123; System.out.println(&quot;具体同事类1发出请求。&quot;); mediator.relay(this); //请中介者转发 &#125;&#125;//具体同事类class ConcreteColleague2 extends Colleague &#123; public void receive() &#123; System.out.println(&quot;具体同事类2收到请求。&quot;); &#125; public void send() &#123; System.out.println(&quot;具体同事类2发出请求。&quot;); mediator.relay(this); //请中介者转发 &#125;&#125; 应用场景 当对象之间存在复杂的网状结构关系而导致依赖关系混乱且难以复用时。 当想创建一个运行于多个类之间的对象，又不想生成新的子类时。 模式的扩展 在实际开发中，通常采用以下两种方法来简化中介者模式，使开发变得更简单。 不定义中介者接口，把具体中介者对象实现成为单例。 同事对象不持有中介者，而是在需要的时候直接获取中介者对象并调用。 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"行为型模式","permalink":"http://persian.gitee.io/blog/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"适配器模式","slug":"结构型模式-适配器模式","date":"2021-03-05T13:02:06.574Z","updated":"2021-03-11T14:35:05.511Z","comments":false,"path":"article/20211905081917.html","link":"","permalink":"http://persian.gitee.io/blog/article/20211905081917.html","excerpt":"","text":"概念 定义：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。类适配器模式可采用多重继承方式实现，如 C++ 可定义一个适配器类来同时继承当前系统的业务接口和现有组件库中已经存在的组件接口；Java 不支持多继承，但可以定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。 优点 客户端通过适配器可以透明地调用目标接口。 复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。 将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。 在很多业务场景中符合开闭原则。 缺点 适配器编写过程需要结合业务场景全面考虑，可能会增加系统的复杂性。 增加代码阅读难度，降低代码可读性，过多使用适配器会使系统代码变得凌乱。 模式的结构与实现模式的结构 目标（Target）接口： 当前系统业务所期待的接口，它可以是抽象类或接口。 适配者（Adaptee）类： 它是被访问和适配的现存组件库中的组件接口。 适配器（Adapter）类： 它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。 模式的实现1. 类适配器模式的代码如下:123456789101112131415161718192021222324252627282930//客户端代码public class ClassAdapterTest&#123; public static void main(String[] args) &#123; System.out.println(&quot;类适配器模式测试：&quot;); Target target = new ClassAdapter(); target.request(); &#125;&#125;//目标接口interface Target&#123; public void request();&#125;//适配者接口class Adaptee&#123; public void specificRequest() &#123; System.out.println(&quot;适配者中的业务代码被调用！&quot;); &#125;&#125;//类适配器类class ClassAdapter extends Adaptee implements Target&#123; public void request() &#123; specificRequest(); &#125;&#125; 2. 对象适配器模式的代码如下： 说明：对象适配器模式中的“目标接口”和“适配者类”的代码同类适配器模式一样，只要修改适配器类和客户端的代码即可。 1234567891011121314151617181920212223//客户端代码public class ObjectAdapterTest&#123; public static void main(String[] args) &#123; System.out.println(&quot;对象适配器模式测试：&quot;); Adaptee adaptee = new Adaptee(); Target target = new ObjectAdapter(adaptee); target.request(); &#125;&#125;//对象适配器类class ObjectAdapter implements Target&#123; private Adaptee adaptee; public ObjectAdapter(Adaptee adaptee) &#123; this.adaptee=adaptee; &#125; public void request() &#123; adaptee.specificRequest(); &#125;&#125; 应用场景 以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。 使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。 模式的扩展 适配器模式（Adapter）可扩展为双向适配器模式，双向适配器类既可以把适配者接口转换成目标接口，也可以把目标接口转换成适配者接口。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//客户端代码public class TwoWayAdapterTest&#123; public static void main(String[] args)&#123; System.out.println(&quot;目标通过双向适配器访问适配者：&quot;); TwoWayAdaptee adaptee=new AdapteeRealize(); TwoWayTarget target=new TwoWayAdapter(adaptee); target.request(); System.out.println(&quot;-------------------&quot;); System.out.println(&quot;适配者通过双向适配器访问目标：&quot;); target=new TargetRealize(); adaptee=new TwoWayAdapter(target); adaptee.specificRequest(); &#125;&#125;//目标接口interface TwoWayTarget&#123; public void request();&#125;//适配者接口interface TwoWayAdaptee&#123; public void specificRequest();&#125;//目标实现class TargetRealize implements TwoWayTarget&#123; public void request()&#123; System.out.println(&quot;目标代码被调用！&quot;); &#125;&#125;//适配者实现class AdapteeRealize implements TwoWayAdaptee&#123; public void specificRequest()&#123; System.out.println(&quot;适配者代码被调用！&quot;); &#125;&#125;//双向适配器class TwoWayAdapter implements TwoWayTarget,TwoWayAdaptee&#123; private TwoWayTarget target; private TwoWayAdaptee adaptee; public TwoWayAdapter(TwoWayTarget target)&#123; this.target=target; &#125; public TwoWayAdapter(TwoWayAdaptee adaptee)&#123; this.adaptee=adaptee; &#125; public void request()&#123; adaptee.specificRequest(); &#125; public void specificRequest()&#123; target.request(); &#125;&#125; 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"结构型模式","permalink":"http://persian.gitee.io/blog/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"代理模式","slug":"结构型模式-代理模式","date":"2021-03-05T13:02:06.568Z","updated":"2021-03-05T12:17:48.421Z","comments":false,"path":"article/20211605081641.html","link":"","permalink":"http://persian.gitee.io/blog/article/20211605081641.html","excerpt":"","text":"概念 代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。通俗的来讲代理模式就是我们生活中常见的中介。 为什么要用代理模式？ 中介隔离作用： 在某些情况下，一个客户类不想或者不能直接引用一个委托对象，而代理类对象可以在客户类和委托对象之间起到中介的作用，其特征是代理类和委托类实现相同的接口。 开闭原则，增加功能： (用于AOP) 代理类除了是客户类和委托类的中介之外，我们还可以通过给代理类增加额外的功能来扩展委托类的功能，这样做我们只需要修改代理类而不需要再修改委托类，符合代码设计的开闭原则。代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后对返回结果的处理等。代理类本身并不真正实现服务，而是同过调用委托类的相关方法，来提供特定的服务。真正的业务功能还是由委托类来实现，但是可以在业务功能执行的前后加入一些公共的服务。例如我们想给项目加入缓存、日志这些功能，我们就可以使用代理类来完成，而没必要打开已经封装好的委托类。 有哪几种代理模式？ 静态代理 动态代理（JDK接口代理） cglib动态代理 1. 静态代理 需要定义接口或父类； 代理对象与目标对象需要实现（或继承）同一个接口（或父类）； 缺点： 接口（或父类）改变时，代理对象与目标对象据需要一起改动； 每个目标对象均需要创建相应的代理对象，不方便的源码的管理，并且编译的class包也比较臃肿； 2. 动态代理 在动态代理中，我们不需要再为目标对象创建相应的代理对象，只需要创建一个代理对象生成工厂即可。真正的代理对象，JDK运行时会为我们动态创建。 需要实现接口InvocationHandler.invoke() – 里面写一些增强处理的逻辑。 自定义的代理工厂，使用 Proxy.newProxyInstance(接口对象的ClassLoader,接口对象的Class&lt;?&gt;[],InvocationHandler实现类)动态创建目标对象的代理对象； 缺点： 由于动态代理也叫JDK接口代理，字面意思也说明了，目标对象必须是某个接口的实现类； 3. cglib动态代理 – 子类代理 由于JDK实现动态代理需要实现类通过接口定义业务方法，对于没有接口的类，如何实现动态代理呢，这就需要CGLib了。CGLib采用了非常底层的字节码技术，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。但因为采用的是继承，所以不能对final修饰的类进行代理，并且被final修饰的方法，也不会被拦截。JDK动态代理与CGLib动态代理均是实现Spring AOP的基础。 ① 实现接口MethodInterceptor，里面放一些增强处理的逻辑 ② 使用Enhancer创建目标类子类代理对象，并把实现了MethodInterceptor接口的实现类对象，放入enhancer.setCallback()中； 总结： CGLIB创建的动态代理对象比JDK创建的动态代理对象的性能更高，但是CGLIB创建代理对象时所花费的时间却比JDK多得多。所以对于单例的对象，因为无需频繁创建对象，用CGLIB合适，反之使用JDK方式要更为合适一些。同时由于CGLib由于是采用动态创建子类的方法，对于final修饰的方法无法进行代理。 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"结构型模式","permalink":"http://persian.gitee.io/blog/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"原型模式","slug":"创建型模式-原型模式","date":"2021-03-05T13:02:06.561Z","updated":"2021-03-07T15:05:12.429Z","comments":false,"path":"article/20211305081317.html","link":"","permalink":"http://persian.gitee.io/blog/article/20211305081317.html","excerpt":"","text":"概念 经典定义： 一种基于现有对象的模板，通过克隆的方式创建对象的模式。原型模式的核心思想是，通过拷贝指定的“原型实例（对象）”，创建跟该对象一样的新对象。简单理解就是“克隆指定对象“。注意： 需要拷贝的原型类必须实现”java.lang.Cloneable”接口，然后重写Object类中的clone方法，从而才可以实现类的拷贝。 1234567/** @author unascribed * @see java.lang.CloneNotSupportedException * @see java.lang.Object#clone() * @since JDK1.0 */public interface Cloneable &#123;&#125; 注意：Cloneable是一个标记接口，所谓标记接口就是该接口为定义任何内容。标记接口的作用就是为所有实现该接口的类赋予一种特殊标记。只有当一个类实现了接口Cloneable接口后，该类才被赋予调用重写Object类的clone()方法的权利。否则会抛出“CloneNotSupportedException“异常。 两种方式 对拷贝得到副本的数据修改，不会影响到原来的对象。这是因为copy的对象是一个独立的对象，可以通过打印原型类对象，与拷贝对象的地址值，进行对比。 一、“浅拷贝” 1、当类的成员变量是基本数据类型时，浅拷贝会复制该属性的值赋值给新对象。2、当成员变量是引用数据类型时，浅拷贝复制的是引用数据类型的地址值。这种情况下，当拷贝出的某一个类修改了引用数据类型的成员变量后，会导致所有拷贝出的类都发生改变。 代码场景 案例：一个人，名叫“小菜鸟”，职业是“程序员”。现在因项目需求剧增，导致一个人无法按时完成任务，从而需要克隆出来属性与其一模一样的优秀程序员。 1234567891011121314151617181920212223242526272829// 原型类public class Person implements Cloneable &#123; private String name; private String occupation; // ... 省略构造方法，setter,getter方法 @Override protected Object clone()&#123; Person person = null; try&#123; // 调用父类的clone(),完成浅拷贝。 person = (Person) super.clone(); &#125;catch (CloneNotSupportedException e)&#123; e.printStackTrace(); &#125; return person; &#125; &#125;// 单元测试public class TestDemo&#123; public static void main (String[] args)&#123; Person person = new Person(&quot;原型类&quot;,&quot;这是原型类哦~&quot;); Person copyPersion = (Persion)person.clone(); System.err.println(&quot;原型类：&quot;+person); System.err.println(&quot;浅拷贝类：&quot;+copyPersion); &#125;&#125; 二、“深拷贝” 深拷贝不仅会复制成员变量为基本数据类型的值，给新对象。还会给是引用数据类型的成员变量申请储存空间，并复制引用数据类型成员变量的对象。这样拷贝出的新对象就不怕修改了是引用数据类型的成员变量后，对其它拷贝出的对象造成影响了 代码场景 在Person类中添加一个是引用数据类型的成员属性Computer。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394// Computer类 -- 将作为原型类的成员变量类public class Computer implements Cloneable,Serializable &#123; private static final long seriaVersion = 1L; private String color; private String brand; // ...省略构造方法，setter,getter @Override protected Object clone() throws CloneNotSupportedException &#123; ///由于该类的成员变量均为String，所以使用浅拷贝即可。 super.clone(); &#125;&#125;// 原型类public class Person implements Cloneable,Serializable &#123; private static final long seriaVersion = 11L; private String name; private String occupation; private Computer computer; // ... 省略构造方法，setter,getter方法 // 对于成员变量是Computer,所以这里有两种方式 // 方式一 ： 缺陷，需要单独处理所有要克隆的类中的引用数据类型。 @Override protected Object clone()&#123; Person person = null; try&#123; // 调用父类的clone(),完成浅拷贝。-- 只会拷贝父类中基本数据类型String的数据 person = (Person) super.clone(); // 调用引用类中的clone()克隆出一个新的对象，并赋值给当前原型类的该引用类的成员变量 // 这样的操作之后，该成员变量computer不再是复制的地址值，从而解决浅拷贝的问题。 person.computer = (Computer) this.computer.clone(); &#125;catch (CloneNotSupportedException e)&#123; e.printStackTrace(); &#125; return person; &#125; // 方式二 ： 通过序列化对象实现深拷贝。（推荐该方式） public Object deepClone ()&#123; // 声明流对象 ByteArrayOutputStream bos = null; ByteArrayInputSteam bis = null; ObjectOutputStream oos = null; ObjectInputStream ois = null; try&#123; // 创建序列化流 bos = new ByteArrayOutputStream(); oos = new ObjectOutputStream(bos); // 将当前对象以对象流输出 oos.writeObject(this); // 创建反序列化流 bis = new ByteArrayInputSteam(bos.toByteArray()); ois = new ObjectInputStream(bis); // 将流对象反序列化，从而实现深拷贝 return ois.readObject(); &#125;catch (Exception e)&#123; e.printStackTrace(); return null; &#125;finally&#123; try&#123; // 释放资源 bos.close(); bis.close(); oos.close(); ois.close(); &#125;catch (IOException ioException)&#123; ioException.printStackTrace(); &#125; &#125; &#125;&#125;//测试类public class TestDeepCopyDemo &#123; public static void main (String[] args)&#123; Person person = new Person(&quot;原型类&quot;,&quot;原型类哦~&quot;,new Computer(&quot;黑色&quot;,&quot;联想&quot;)); System.err.println(&quot;原型类：&quot;+person); // 方式一 Person deepCopyPerson1 = (Person)person.clone(); System.err.println(&quot;方式一深拷贝：&quot;+deepCopyPerson1); // 方式二 Person deepCopyPerson2 = (Person)person.deepClone(); System.err.println(&quot;方式二深拷贝：&quot;+deepCopyPerson2); &#125;&#125; 总结 通过原型模式可以简化创建重量级对象的过程，并提高程序的效率。 原型设计模式是动态获取对象运行时的状态进行创建对象的。 使用原型设计模式可以使代码变的更加灵活，因为当原型类发生变化（增、减属性）时，克隆的对象也会做出相应的改变。 对已经创建好的类进行改造，使其支持克隆时需要修改源代码，这就是违背了ocp原则。 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"创建型模式","slug":"创建型模式","permalink":"http://persian.gitee.io/blog/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"单例模式","slug":"创建型模式-单例模式","date":"2021-03-05T13:02:06.558Z","updated":"2021-03-06T03:22:02.792Z","comments":false,"path":"article/20211205081216.html","link":"","permalink":"http://persian.gitee.io/blog/article/20211205081216.html","excerpt":"","text":"概念 GOF书中提到的定义： 保证一个类仅有一个实例，并提供一个访问它的全局访问点。解释如下： 单例类只能有一个实例； 单例类必须自己创建自己的唯一实例； 单例类必须给所有的其他对象提供自己这唯一的实例。(由于这个唯一实例是供全局使用的，那么这对象注定被static关键修饰的) 应用场景 单例模式确保某个类只有一个实例，而且自行实例化，并向整个系统提供这个实例。在计算机系统中，线程池、缓存、日至对象、对话框、打印机、显卡驱动程序的对象常被设计为单例模式。这些应用或多或少的具备系统资源管理器的功能。每台计算机可以有若干个打印机，但只能有一个Printer Spooler，以避免两个打印作业同时输出到打印机中。每台计算机可以有若干通信端口，系统应当集中管理这些通信端口，以避免一个通信端口同时被两个请求同时调用。总之，选择单例模式就是为了避免不一致状态，避免政出多头。 4种方式一、懒汉式单例 懒汉式，顾名思义就是实例在用到的时候才去创建，“比较懒”，用的时候才去检查有没有实例，如果有则返回，没有则新建。有线程安全和线程不安全两种写法，区别就是synchronized关键字。 12345678910111213//懒汉式单例类.在第一次调用的时候实例化自己 public class Singleton &#123; private Singleton() &#123;&#125; private static Singleton single=null; //静态工厂方法 -- 注：下面的关于线程安全的问题，会在这个方法进行改造 public static Singleton getInstance() &#123; if (single == null) &#123; single = new Singleton(); &#125; return single; &#125;&#125; Singleton通过将构造方法限定为private避免了类在外部被实例化，在同一个虚拟机范围内，Singleton的唯一实例只能通过getInstance()方法访问。 （事实上，通过Java反射机制是能够实例化构造方法为private的类的，那基本上会使所有的Java单例实现失效。） 但是以上懒汉式单例的实现没有考虑线程安全问题，它是线程不安全的，并发环境下很可能出现多个Singleton实例，要实现线程安全，有以下三种方式，都是对getInstance这个方法改造，保证了懒汉式单例的线程安全。(这里需要有对线程知识的了解。) 1. 在getInstance方法上加同步12345public static synchronized Singleton getInstance() &#123; if (single &#x3D;&#x3D; null) &#123; single &#x3D; new Singleton(); &#125; return single; 2. 双重检查锁定 双检锁，又叫双重校验锁，综合了懒汉式和饿汉式两者的优缺点整合而成。在下面代码实现中，特点是在synchronized关键字内外都加了一层if条件判断，这样既保证了线程安全，又比直接上锁提高了执行效率，还节省了内存空间。 12345678910public static Singleton getInstance() &#123; if (singleton &#x3D;&#x3D; null) &#123; synchronized (Singleton.class) &#123; if (singleton &#x3D;&#x3D; null) &#123; singleton &#x3D; new Singleton(); &#125; &#125; &#125; return singleton;&#125; 3. 静态内部类 静态内部类的方式效果类似双检锁，但实现更简单。但这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。 123456789public class Singleton &#123; private static class LazyHolder &#123; private static final Singleton INSTANCE &#x3D; new Singleton(); &#125; private Singleton ()&#123;&#125; public static final Singleton getInstance() &#123; return LazyHolder.INSTANCE; &#125; &#125; 这种比上面1、2都好一些，既实现了线程安全，又避免了同步带来的性能影响。 二、饿汉式单例 饿汉式，从名字上也很好理解，就是“比较勤”，实例在初始化的时候就已经建好了，不管你有没有用到，都先建好了再说。好处是没有线程安全的问题，坏处是浪费内存空间。 12345678910//饿汉式单例类.在类初始化时，已经自行实例化 public class Singleton1 &#123; private Singleton1() &#123;&#125; //final关键字决定了，这是一个静态对象，天生线程安全的。 private static final Singleton1 single = new Singleton1(); //静态工厂方法 public static Singleton1 getInstance() &#123; return single; &#125;&#125; 三、登记式单例(可忽略)12345678910111213141516171819202122232425262728293031323334353637//类似Spring里面的方法，将类名注册，下次从里面直接获取。public class Singleton3 &#123; private static Map&lt;String,Singleton3&gt; map = new HashMap&lt;String,Singleton3&gt;(); static&#123; Singleton3 single = new Singleton3(); map.put(single.getClass().getName(), single); &#125; //保护的默认构造子 protected Singleton3()&#123;&#125; //静态工厂方法,返还此类惟一的实例 public static Singleton3 getInstance(String name) &#123; if(name == null) &#123; name = Singleton3.class.getName(); System.out.println(&quot;name == null&quot;+&quot;---&gt;name=&quot;+name); &#125; if(map.get(name) == null) &#123; try &#123; map.put(name, (Singleton3) Class.forName(name).newInstance()); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; return map.get(name); &#125; //一个示意性的商业方法 public String about() &#123; return &quot;Hello, I am RegSingleton.&quot;; &#125; public static void main(String[] args) &#123; Singleton3 single3 = Singleton3.getInstance(null); System.out.println(single3.about()); &#125;&#125; 登记式单例实际上维护了一组单例类的实例，将这些实例存放在一个Map（登记薄）中，对于已经登记过的实例，则从Map直接返回，对于没有登记的，则先登记，然后返回。 这里我对登记式单例标记了可忽略，我的理解来说，首先它用的比较少，另外其实内部实现还是用的饿汉式单例，因为其中的static方法块，它的单例在类被装载的时候就被实例化了。 四、枚举类式单例12345678910public enum SingletonEnum &#123; ; private String code; private String desc; public SingletonEnum(String code,String desc)&#123; this.code = code; this.desc = desc; &#125;&#125; 枚举的方式是比较少见的一种实现方式，但是看上面的代码实现，却更简洁清晰。并且她还自动支持序列化机制，绝对防止多次实例化。 区别对比称呼的角度 饿汉就是类一旦加载，就把单例初始化完成，保证getInstance的时候，单例是已经存在的了；懒汉比较懒，只有当调用getInstance的时候，才回去初始化这个单例。 线程安全的角度 饿汉式天生就是线程安全的，可以直接用于多线程而不会出现问题；懒汉式本身是非线程安全的，为了实现线程安全有几种写法，分别是上面的1、2、3，这三种实现在资源加载和性能方面有些区别。 资源加载和性能的角度 饿汉式在类创建的同时就实例化一个静态对象出来，不管之后会不会使用这个单例，都会占据一定的内存，但是相应的，在第一次调用时速度也会更快，因为其资源已经初始化完成;懒汉式顾名思义，会延迟加载，在第一次使用该单例的时候才会实例化对象出来，第一次调用时要做初始化，如果要做的工作比较多，性能上会有些延迟，之后就和饿汉式一样了。 至于1、2、3这三种实现又有些区别： 第1种，在方法调用上加了同步，虽然线程安全了，但是每次都要同步，会影响性能，毕竟99%的情况下是不需要同步的， 第2种，在getInstance中做了两次null检查，确保了只有第一次调用单例的时候才会做同步，这样也是线程安全的，同时避免了每次都同步的性能损耗 第3种，利用了classloader的机制来保证初始化instance时只有一个线程，所以也是线程安全的，同时没有性能损耗，所以一般我倾向于使用这一种。 题外话什么是线程安全？ 如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。或者说：一个类或者程序所提供的接口对于线程来说是原子操作，或者多个线程之间的切换不会导致该接口的执行结果存在二义性,也就是说我们不用考虑同步的问题，那就是线程安全的。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"创建型模式","slug":"创建型模式","permalink":"http://persian.gitee.io/blog/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"SpringBean","slug":"Spring-SpringBean","date":"2021-03-05T13:02:06.557Z","updated":"2021-03-05T12:03:50.532Z","comments":false,"path":"article/20210305080340.html","link":"","permalink":"http://persian.gitee.io/blog/article/20210305080340.html","excerpt":"","text":"概念 在Spring中，那些组成应用程序的主体及由SpringIOC容器所管理的对象，被称之为bean。简单地讲，bean 就是由 IOC 容器初始化、装配及管理的对象，除此之外，bean 就与应用程序中的其他对象没有什么区别了。而bean的定义以及bean相互间的依赖关系将通过配置元数据来描述。 Spring中的bean默认都是单例的，这些单例Bean在多线程程序下如何保证线程安全呢？ 例如: 对于Web应用来说，Web容器对于每个用户请求都创建一个单独的Sevlet线程来处理请求，引入Spring框架之后，每个Action都是单例的，那么对于Spring托管的单例Service Bean，如何保证其安全呢？ Spring的单例是基于BeanFactory也就是Spring容器的，单例Bean在此容器内只有一个，Java的单例是基于 JVM，每个 JVM 内只有一个实例。 Bean作用域 singleton: 在Spring IoC容器中仅存在一个Bean实例，Bean以单例方式存在，默认值; prototype: 每次从容器中调用Bean时，都返回一个新的实例，即每次调用getBean()时，相当于执行new XxxBean(); request: 每次HTTP请求都会创建一个新的Bean，该该作用域仅适用于WebApplicationContext环境; session: 同一个HTTP Session共享一个Bean，不同Session使用不同Bean，仅适用于WebApplicationContext环境; globalSession: 一般用于Portlet应用环境，该作用域仅适用于WebApplicationContext环境; 总结：* 五种作用域中，request、session 和 global session 三种作用域仅在基于web的应用中使用（不必关心你所采用的是什么web应用框架），只能用在基于web的Spring ApplicationContext环境。 Spring Bean生命周期 概括 实例化 Instantiation 属性赋值 Populate 初始化 Initialization 销毁 Destruction注：前三步在doCreate()方法中: //忽略了无关代码 protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args) throws BeanCreationException &#123; // Instantiate the bean. BeanWrapper instanceWrapper = null; if (instanceWrapper == null) &#123; // 实例化阶段！ instanceWrapper = createBeanInstance(beanName, mbd, args); &#125; // Initialize the bean instance. Object exposedObject = bean; try &#123; // 属性赋值阶段！ populateBean(beanName, mbd, instanceWrapper); // 初始化阶段！ exposedObject = initializeBean(beanName, exposedObject, mbd); &#125; &#125; 详细的说 Bean容器找到配置文件中 Spring Bean 的定义。 Bean容器利用Java Reflection API创建一个Bean的实例。 如果涉及到一些属性值 利用set方法设置一些属性值。 如果Bean实现了BeanNameAware接口，调用setBeanName()方法，传入Bean的名字。 如果Bean实现了BeanClassLoaderAware接口，调用setBeanClassLoader()方法，传入ClassLoader对象的实例。 如果Bean实现了BeanFactoryAware接口，调用setBeanClassLoader()方法，传入ClassLoader对象的实例。 与上面的类似，如果实现了其他*Aware接口，就调用相应的方法。 如果有和加载这个Bean的Spring容器相关的BeanPostProcessor对象，执行postProcessBeforeInitialization()方法。 如果Bean实现了InitializingBean接口，执行afterPropertiesSet()方法。 如果Bean在配置文件中的定义包含init-method属性，执行指定的方法。 如果有和加载这个Bean的Spring容器相关的BeanPostProcessor对象，执行postProcessAfterInitialization()方法。 当要销毁Bean的时候，如果Bean实现了DisposableBean接口，执行destroy()方法。 当要销毁Bean的时候，如果Bean在配置文件中的定义包含destroy-method属性，执行指定的方法。 Spring中的单例Bean是线程安全的吗？ Spring容器中的Bean是否线程安全，容器本身并没有提供Bean的线程安全策略。因此可以说Spring容器中的Bean本身不具备线程安全的特性，但是具体还是要结合具体scope的Bean去研究。 线程安全这个问题，要从单例与原型Bean分别进行说明。 原型Bean： 对于原型Bean,每次创建一个新对象，也就是线程之间并不存在Bean共享，自然是不会有线程安全的问题。 单例Bean： 对于单例Bean,所有线程都共享一个单例实例Bean,因此是存在资源的竞争。 无状态的单例Bean：也就是线程中的操作不会对Bean的成员执行查询以外的操作，那么这个单例Bean是线程安全的。比如Spring mvc 的 Controller、Service、Dao等，这些Bean大多是无状态的，只关注于方法本身。 有状态的单例Bean：就是没有实例变量的对象，不能保存数据，是不变类，是线程安全的。bean一旦实例化就被加进会话池中，各个用户都可以共用。即使用户已经消亡，bean 的生命期也不一定结束，它可能依然存在于会话池中，供其他用户调用。由于没有特定的用户，那么也就不能保持某一用户的状态，所以叫无状态bean。但无状态会话bean 并非没有状态，如果它有自己的属性（变量），那么这些变量就会受到所有调用它的用户的影响，这是在实际应用中必须注意的。 那么对于有状态的单例Bean，如何保证线程安全？ Spring官方提供的bean，一般提供了通过ThreadLocal去解决线程安全的方法。 比如RequestContextHolder、TransactionSynchronizationManager、LocaleContextHolder等。 使用ThreadLocal的好处使得多线程场景下，多个线程对这个单例Bean的成员变量并不存在资源的竞争，因为ThreadLocal为每个线程保存线程私有的数据。这是一种以空间换时间的方式。当然也可以通过加锁的方法来解决线程安全，这种以时间换空间的场景在高并发场景下显然是不实际的。 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://persian.gitee.io/blog/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://persian.gitee.io/blog/tags/spring/"},{"name":"bean","slug":"bean","permalink":"http://persian.gitee.io/blog/tags/bean/"}]},{"title":"Java基础","slug":"Java基础","date":"2021-03-05T13:02:06.555Z","updated":"2021-03-05T12:17:48.710Z","comments":false,"path":"article/20213903103930.html","link":"","permalink":"http://persian.gitee.io/blog/article/20213903103930.html","excerpt":"","text":"1.⾯向对象和⾯向过程的区别？① ⾯向过程 ⾯向过程性能⽐⾯向对象⾼。 因为类调⽤时需要实例化，开销比较⼤，比较消耗资源，所以当性能是最重要的考量因素的时候，⽐如单⽚机、嵌⼊式开发、Linux/Unix 等⼀般采⽤⾯向过程开发。但是⾯向过程没有⾯向对象易维护、易复⽤、易扩展。 ② ⾯向对象 ⾯向对象易维护、易复⽤、易扩展。 2.java抽象类和普通类的区别？① 抽象类可以有构造函数，抽象方法不能被声明为静态② 象类不能被实例化3.Java 方法访问权限修饰？① private私有成员属性和方法，只有本类可以调用，除内部类特殊情况② 默认不写只有本类 同一个包下面的类③ protected本类 同包 不同包的子类④ public 本类 同包 不同包的类 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://persian.gitee.io/blog/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://persian.gitee.io/blog/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"Java集合","slug":"Java基础-集合","date":"2021-03-05T13:02:06.554Z","updated":"2021-03-05T12:17:48.592Z","comments":false,"path":"article/20211903111947.html","link":"","permalink":"http://persian.gitee.io/blog/article/20211903111947.html","excerpt":"","text":"CollectionListArraylist 动态数组 能够实现随机存取 – 实现了RandomAccess接口 fail-fast机制① modCount在Abstractlist中定义② 在使用迭代器遍历list时，如果modCount和exceptedCount不匹配，就会直接抛出异常③ 使用迭代器自带的remove时，如果删除了list中元素，不会出现fail-fast， 因为迭代器会调整modCount和expectedCount值 自定义序列化方法① 因为arraylist的底层数组中，可能存在值为null的元素，序列化这些元素是没意义的， 因此自定义序列化方法，只序列化数组中非null的元素② 通过readObject和writeObject方法实现 有一个初始容量（16）① 扩容：capacity = 1.5 * capacity② 通过Arrays.copyOf() - &gt; System.copyOf()③ Arraylist是插入前扩容，扩容逻辑为ensureCapacityInternal() –&gt; ensureExplicitCapacity() —&gt; grow() 插入时，判断容器中的元素是否超过某个阈值，超过则代表快溢出，会进行扩容 Linkedlist 动态数组 双向链表 不能随机访问，不能通过下标获取元素 适合插入删除多的场合 – 更新，删除元素效率高 SetHashSet 不保证元素顺序 元素插入的顺序与输出顺序不一致 在Set中元素还是有顺序的，根据元素的hashcode排序 LinkedHashSet 基于LinkedHashMap实现 使用链表维护元素的次序 TreeSet 底层基于TreeMap实现 两种排序：① 自然排序 ② 定制排序 不是通过hashcodeh和equals来比较元素，是通过compare或compareTo来判断元素是否相等 MapHashMap 扩容，需要遍历旧table，再遍历每个table中每个元素的单向链表，取得entry后，重新计算hash，然后存放到新table的对应位置 LinkedHashMap 哈希表和链表实现 每个元素用双向链表进行连接 扩容时遍历双向链表，重新计算每个元素的hash即可 TreeMap 基于红黑树 自然排序 ① 所有key必须实现Comparable接口 – 每一个key-value节点作为红黑树的一个节点 定制排序 ① 定义TreeMap时，创建一个comparator对象，该对象对所有的key进行排序 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://persian.gitee.io/blog/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://persian.gitee.io/blog/tags/%E5%9F%BA%E7%A1%80/"},{"name":"集合","slug":"集合","permalink":"http://persian.gitee.io/blog/tags/%E9%9B%86%E5%90%88/"}]},{"title":"Java高级特性——反射","slug":"Java基础-反射","date":"2021-03-05T13:02:06.552Z","updated":"2021-03-05T12:00:37.466Z","comments":false,"path":"article/20215805075828.html","link":"","permalink":"http://persian.gitee.io/blog/article/20215805075828.html","excerpt":"","text":"概念 java反射机制是指在运行状态中，对于任意一个类，都能够知道这类的所有属性和方法；对于任意一个对象，都能够调用它的所有属性和方法。 —— 对于这种动态的获取任意类的信息和动态的调用其方法的功能，称为java语言的反射机制。 反射机制类 Class – 类，三种获取方式 Feild – 成员变量类 Method – 方法类 Constructor – 构造方法类 Modifier – 访问权限类 反射机制提供了哪些功能？ 在运行时，判定任意对象所属的类 –Class 在运行时，构造任意一个类的对象 –对象5种创建方式：Class.newInstance() 在运行时，判定任意对象的所有方法和成员变量 – Feild、Method 在运行时，调用任意对象的方法 – Method 生成动态代理 Java反射机制的应用 ① class对象的获取; 1object.getClass()、Object.class、Class.forName(&quot;java.lang.Object&quot;) ② 获取class对象的摘要信息 12345678910111213class1.isPrimitive();&#x2F;&#x2F;是否基础类型class1.isArray();&#x2F;&#x2F;是否集合类class1.isAnnotation();&#x2F;&#x2F;是否注解类class1.isInterface();&#x2F;&#x2F;是否接口类class1.isEnum();&#x2F;&#x2F;是否枚举类class1.isAnonymousClass();&#x2F;&#x2F;是否匿名内部类class1.isAnnotationPresent(Deprecated.class);&#x2F;&#x2F;是否被某个注解类修饰class1.getName();&#x2F;&#x2F;获取class名字 包含包名路径class1.getPackage();&#x2F;&#x2F;获取class的包信息class1.getSimpleName();&#x2F;&#x2F;获取class类名class1.getModifiers();&#x2F;&#x2F;获取class访问权限class1.getDeclaredClasses();&#x2F;&#x2F;内部类class1.getDeclaringClass();&#x2F;&#x2F;外部类 ③ 获取class对象的属性、方法、构造函数等;④ class对象动态生成;⑤ 动态调用函数;⑥ 通过反射机制获取泛型类型;⑦ 通过反射机制获取注解信息; 用途 逆向代码，如反编译 配合注解：spring mybatis 等 动态生成类框架：hibernate等 AOP的核心技术 优点与缺陷 优点： 运行期类型的判断，动态类加载，动态代理使用反射。 缺陷： 性能是一个问题，反射相当于一系列解释操作，通知jvm要做的事情，性能比直接的java代码要慢很多。 总结 Java的反射机制在平时的业务开发过程中很少使用到，但是在一些基础框架的搭建上应用非常广泛 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://persian.gitee.io/blog/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://persian.gitee.io/blog/tags/%E5%9F%BA%E7%A1%80/"},{"name":"反射","slug":"反射","permalink":"http://persian.gitee.io/blog/tags/%E5%8F%8D%E5%B0%84/"}]},{"title":"JVM复习点","slug":"Java基础-JVM复习点","date":"2021-03-05T13:02:06.550Z","updated":"2021-03-05T12:17:48.983Z","comments":false,"path":"article/20213303113340.html","link":"","permalink":"http://persian.gitee.io/blog/article/20213303113340.html","excerpt":"","text":"类加载机制加载 全限定名获取定义此类的二进制流 静态存储结构转为方法区的数据结构 java堆中生成class对象作为入口验证 文件格式（魔数 版本 编码等） 元数据（集成关系 重载参数等） 字节码（指令跳转 类型转换等） 符号引用（全限定名找到对应类 其方法与字段 其访问性等）准备 类变量赋初值解析 常量池的符号引用替换为直接引用 类或接口 字段 类方法 接口方法的解析初始化 ()是类变量赋值动作和静态语句块的合并 类 ① 父类静态语句块优于子类变量赋值 ② JVM保证父类初始化已提取完成 接口 ① 仅当接口的变量被使用时才初始化 多线程中会加锁，一个线程执行初始化，其他线程阻塞等待使用 卸载类加载器 Bootstrap ClassLoader Extension ClassLoader Application ClassLoader 自定义类加载器双亲委派机制 1.避免类重复加载 2.避免java核心api被篡改 内存模型主内存和工作内存内存结构对象在jvm内存中如何分配和流转如何设置jvm参数GCyoung gc时机 eden区满触发old gc时机 老年代可用连续内存空间小于新生代历次 young gc进入老年代对象总和的平均大小 老年代空间不足 老年代使用率超92% full gc young gc + old gc + 永久代gc 频繁full gc 并发数过大，导致young gc频繁且存活对象太多，survivor区过小，对象频繁进入老年代 大对象过多 内存泄漏 - 类似集合之类一直无限制扩容，导致堆内存不够用 Metaspace加载类过多 误调用System.gc 条件 老年代内存超阈值（92%） 老年代可用空间小于历次young gc后升入老年代的平均对象大小 young gc存活对象过多，survivor放不下，老年代也放不下监控 zabbix、open-falcon工具监控 jstat监控 tomcat的catalina.sh配置打印gc命令，将gc日志导入MAT查看 垃圾回收算法新生代 Serial 复制算法 暂停所有工作线程 ParNew 多线程版的Serial Parallel Scavenge 采用复制算法 并行多线程 吞吐量优先 3.1. 吞吐量=代码时间/（代码时间+GC时间） 3.2. 吞吐量：更有效利用CPU 3.3. 停顿时间：适合与用户交互的程序 总结：复制算法 老年代 Serial Old 标记-整理算法 Parallel Old 标记-整理算法 并行多线程 吞吐量优先 CMS 标记-整理算法 目标为最小停顿时间 缺点: ① 对CPU资源非常敏感 ② 无法处理浮动垃圾 ③ 产生大量碎片 总结：标记整理 G1 标记整理 精确控制停顿 将整个堆划分为固定的区域 跟踪区域的垃圾堆积程度 优先回收垃圾最多的区域 垃圾回收器 新生代（ParNew） 老年代（CMS） G1 查看堆栈和gc情况的命令 jstat -gc pid 如何判断一个对象是否存活 GC Roots 虚拟机栈中引用的对象 方法区类静态属性引用的对象 方法区常量池引用的对象 本地方法栈JNI引用的对象 GC Roots没有引用是第一次标记，不会真正回收，如果没有执行finalize方法，才真正回收 对象进入老年代条件 默认15次young gc还没被回收 young gc过后，同龄对象大小超过survivor的50%，直接进入老年代 young gc后存活对象太多无法放入survivor 优化 加大新生代内存（特别是survivor内存），避免频繁进入老年代 减少躲过GC次数 降低大对象进入老年代的内存门槛 jdk8优化 将永久代放到本地内存中，将常量池和静态变量放到堆中 将类元数据放到本地内存，避免在反射、代理时造成经常full gc 原来每个项目都会占用自己永久代，同个class会占用多个内存空间；优化后metaspaces里只存一份class，提高内存利用率逃逸分析 是一种技术，在开启后，方法栈上的对象在方法执行完后，栈帧弹出，对象就会回收。这样就不需要等内存满时再触发内存回收 同步锁消除 如果发现某个对象只能从一个线程可访问，那么在这个对象上的操作可以不需要同步 逃逸分析把锁消除了 逃逸分析时方法级别，因为jit的即时编译是方法级别 分离对象或标量替换 把对象分解成一个个基本类型，并且内存分配不再是分配在堆上，而是分配在栈上 减少内存使用，因为不用生成对象头 程序内存回收效率高，GC频率减少 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://persian.gitee.io/blog/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://persian.gitee.io/blog/tags/%E5%9F%BA%E7%A1%80/"},{"name":"JVM","slug":"JVM","permalink":"http://persian.gitee.io/blog/tags/JVM/"}]},{"title":"JVM面试","slug":"Java基础-JVM","date":"2021-03-05T13:02:06.549Z","updated":"2021-03-05T12:17:48.537Z","comments":false,"path":"article/20213903103919.html","link":"","permalink":"http://persian.gitee.io/blog/article/20213903103919.html","excerpt":"","text":"1、说一下JVM的主要组成部分及其作用 JVM包括类装载子系统、运行时数据区、执行引擎、本地接口四个部分； 类装载子系统通过类加载器将class字节码加载到JVM运行时数据区的方法区（jdk1.8及以后改为了元空间）；运行时数据区用于存储程序运行时所产生的各种数据；执行引擎负责将class字节码解析为机器指令并交给CPU进行处理，这个过程中可能会调用到系统提供的native方法； 2、描述一下JVM运行时数据区（通常也被叫作JVM内存模型，要区别于Java内存模型~JMM） JVM运行时数据区主要包括堆区、方法区（jdk1.8及以后改为了元空间）、虚拟机栈、本地方法栈、程序计数器五个区域，其中堆区、方法区属于所有线程共享内存区域，虚拟机栈、本地方法栈、程序计数器属于每个线程独享的内存区域； 堆区用于存放对象实例； 方法区用于存储类信息、常量、静态变量、即时编译器编译后的代码等； 虚拟机栈用于存储一个线程在执行方法的过程中产生的数据，一个方法开始被调用就会有一个栈帧入栈，方法执行完毕栈帧出栈，栈帧中包括局部变量表、操作数栈、动态链接、方法出口等； 本地方法栈与虚拟机栈的作用类似，区别在于本地方法栈用于存储线程执行的native方法产生的数据； 程序计数器用于记录线程执行代码的位置，分支、循环、跳转、异常、线程恢复等都依赖于程序计数器，程序计数器也是JVM规范中唯一没有规定OOM（OutOfMemeryError）的内存区域。 3、说一下几种垃圾收集算法及其应用场景 垃圾收集算法主要有标记清除、标记整理、复制算法三种，还有一种分代收集的理论； 标记清除算法标记存活对象，然后清除无用对象，缺点是效率不高，会产生垃圾碎片，主要用于老年代收集，CMS垃圾收集器使用该算法实现； 标记整理算法标记存活对象，然后将存活对象向内存的一端移动，然后清理另一端的内存空间，优点是解决了标记清除算法产生碎片的问题，缺点是需要移动对象，一定程度上降低了垃圾收集效率，SerialOld、ParallelOld、G1收集器使用该算法实现； 复制算法将内存分为大小相等的两块，每次只使用其中的一块，在进行垃圾收集时，将存活对象复制到另一块空闲的内存区域，然后清除掉垃圾对象，复制算法主要应用于年轻代收集，因为年轻的对象大都是存活时间短，存活对象少，使用复制算法效率高，缺点是内存利用率低，Serial、ParNew、Parallel Scavenge收集器使用该算法实现。 4、说一下常见的垃圾收集器及其所使用的垃圾收集算法 目前常用的垃圾收集器大概有七种，其中年轻代垃圾收集器包括Serial、ParNew、Parallel Scavenge，这三种垃圾收集器使用复制算法实现，老年代收集器包括SerialOld、ParallelOld、CMS，其中SerialOld、ParallelOld使用标记整理算法实现，CMS使用标记清除算法实现，整堆垃圾收集器G1使用标记整理算法实现。 Serial是一种单线程垃圾收集器，标记和清理阶段都是单线程； Parallel Scavenge是一种并行垃圾收集器，可以理解为Serial的多线程版本，特点是吞吐量高； ParNew与Parallel Scavenge类似，但是由于Parallel Scavenge不能与CMS进行配合使用，所以才有了ParNew垃圾收集器； SerialOld是一种单线程垃圾收集器，标记和清理阶段都是单线程； ParallelOld是一种并行垃圾收集器，可以理解为Serial的多线程版本，特点是吞吐量高； CMS是一种以获取最短回收停顿时间为目标的收集器，主要包括初始标记、并发标记、重新标记、并发收集、并发清除五个阶段，初始标记扫描gcroot根对象，该阶段需要STW（Stop The World），并发标记基于初始标扫描的gcroot根对象继续查找，标记出所有与gcroot关联的存活对象，该阶段标记线程与用户线程并发执行，重新标记用于修复在并发标记过程中多标和漏标的情况，多标会产生浮动垃圾，可以在下一次GC进行清理，漏标则会清理存活对象，导致致命bug，漏标的情况在CMS中会使用三色标记中的增量更新进行处理，该阶段需要STW（Stop The World）。并发清理阶段清理线程与用户线程并发执行，用于清除在标记阶段为存活对象打的标记，用户线程新产生的对象会被直接标记为黑色不进行回收，CMS也可以通过参数配置进行内存整理等功能； 整堆收集器G1，使用标记整理算法实现（目前很少用，暂不做详细描述）。 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://persian.gitee.io/blog/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://persian.gitee.io/blog/tags/%E5%9F%BA%E7%A1%80/"},{"name":"JVM","slug":"JVM","permalink":"http://persian.gitee.io/blog/tags/JVM/"}]},{"title":"Java创建对象的5种方式","slug":"Java基础-java对象的创建","date":"2021-03-05T13:02:06.548Z","updated":"2021-03-05T12:00:37.486Z","comments":false,"path":"article/20215905075928.html","link":"","permalink":"http://persian.gitee.io/blog/article/20215905075928.html","excerpt":"","text":"方式 依赖函数 使用new关键字 } → 调用了构造函数 使用Class类的newInstance方法 } → 调用了构造函数 使用Constructor类的newInstance方法 } → 调用了构造函数 使用clone方法 } → 没有调用构造函数 使用反序列化——需要实现Serializable接口 } → 没有调用构造函数 举例 1.使用Constructor类的newInstance方法和Class类的newInstance方法很像， java.lang.reflect.Constructor类里也有一个newInstance方法可以创建对象 12Constructor&lt;Employee&gt; constructor &#x3D; Employee.class.getConstructor();Employee emp3 &#x3D; constructor.newInstance(); 2.使用clone方法无论何时我们调用一个对象的clone方法，jvm就会创建一个新的对象，将前面对象的内容全部拷贝进去。用clone方法创建对象并不会调用任何构造函数要使用clone方法，我们需要先实现Cloneable接口并实现其定义的clone方法 1Object o2 &#x3D; object.clone(); 3.使用反序列化当我们序列化和反序列化一个对象，jvm会给我们创建一个单独的对象。在反序列化时，jvm创建对象并不会调用任何构造函数 12ObjectInputStream in &#x3D; new ObjectInputStream(new FileInputStream(&quot;data.obj&quot;));Object object &#x3D; (Object) in.readObject(); 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://persian.gitee.io/blog/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://persian.gitee.io/blog/tags/%E5%9F%BA%E7%A1%80/"},{"name":"对象创建","slug":"对象创建","permalink":"http://persian.gitee.io/blog/tags/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA/"}]},{"title":"Java多线程","slug":"Java基础-Java多线程","date":"2021-03-05T13:02:06.547Z","updated":"2021-03-04T14:13:54.781Z","comments":false,"path":"article/20211204101246.html","link":"","permalink":"http://persian.gitee.io/blog/article/20211204101246.html","excerpt":"","text":"为什么使用多线程： ① 随着处理器的核心数不断增多，单线程程序已无法发挥多核处理器的优势； ② 线程比进程切换效率更高 概念进程 进程是程序一次执行过程。比如程序从启动到销毁是一个进程 线程 线程是比进程更小的单位。一个进程在执行过程中可以产生多个线程。线程之间可以共享“堆”和“Metadata Space”数据，但拥有独立的“程序计数器”、“虚拟机栈”和“本地方法栈”。所以线程之间切换比进程切换负担小的多 并发与并行① 并发 同一时间段内，多个任务都在执行。他们之间共享cpu的执行时间片段。多个任务之间并不是同时执行的。并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。 ② 并行 同一时刻，多个任务同时执行。可能有多个任务分别在不同的cpu上执行。并行可以充分利用多核处理器的优势 引入问题内存泄露 对象在使用完成后，对它的引用依然没有被释放，导致jvm无法回收该对象，就会造成内存泄漏 ① 静态集合类 静态集合类的生命周期和类一样，所以jvm无法回收它们 ② 数据库连接、网络连接、IO连接等 连接在使用完成后必须主动释放资源，否则jvm无法回收它们 ③ 变量不合理的作用域 变量设置的作用域过大，在对其的使用结束后，jvm依然无法对它进行回收，也有可能造成内存泄漏 ④ 内部类引用外部类 内部类保存对外部类的引用，即使程序已经没有对外部类的引用，也会因为内部类保存了引用而无法回收外部类。 死锁死锁发生条件 ① 互斥条件： 该资源任一时刻只能被一个线程拥有；② 请求与保持条件： 一个线程在获取资源阻塞时，对已获得的资源不释放;③ 不剥夺条件： 一个线程获得的资源在其使用完成之前不能被其他线程主动剥夺，只能由自己主动释放;④ 循环等待条件： 多个线程之间形成首尾相接的循环等待资源关系 避免死锁 只需要破坏四个条件中的任意一个即可:① 互斥条件： 本来就是让线程之间互斥，所以无法破坏;② 请求与保持条件： 一次性申请所有的资源;③ 不剥夺条件： 可以让线程在无法获得资源时，先把已获得资源进行释放;④ 循环等待条件： 按照某一顺序来获取资源 解决死锁 待补充。。。 上下文切换 一般情况下线程数都比cpu核心数要多，cpu只能不断在线程之间切换来执行每一个线程。cpu每次切换都得保存当前状态，和加载下一个线程的状态。这就是上下文切换 线程同步synchronized1. 作用范围 ① 静态方法： 使用的同步锁是类对象，和其他静态同步方法存在锁竞争; ② 非静态方法： 使用的锁是当前对象，同一对象之间存在锁竞争，不同对象之间不存在竞争关系；③ 代码块： 使用的锁是synchronized中传入的对象，依据是否同一对象而决定否存在竞争 2. 底层原理 ① 方法： 待补充..② 代码块： 每个java对象的对象头中都有monitor对象，通过能否获取到monitor对象来判断能否获取锁；. 3. 锁优化3.1. 自旋锁 当线程竞争锁失败时，不直接阻塞自己，而是自旋（空等待，比如一个有限的for循环）一会儿，在自旋的同时重新竞争锁。如果在自旋结束前获得了锁，那么获取锁成功；否则自旋结束后阻塞自己; 自旋锁可以减少线程阻塞造成的线程切换（包括挂起线程和恢复线程） ① 单核处理器情况下，不存在实际的并行。当前线程不阻塞自己，拥有锁的线程就无法执行，锁永远不会释放。进而，如果线程多而处理器少，自旋也会造成不少无谓的浪费；② 自旋锁要占用CPU，如果是计算密集型任务，这一优化通常得不偿失，减少锁的使用是更好的选择；③ 如果锁竞争时间比较长，那么自旋通常不能获得锁，白白浪费自旋占用的CPU时间。这通常发生在所持有时间长，且竞争激烈的场景中，此时应主动禁用自旋锁 使用-XX:-UseSpinning参数关闭自旋锁优化；-XX:PreBlockSpin参数修改默认的自旋次数。 3.2. 偏向锁 偏向锁的目标是减少无竞争且只有一个线程使用锁的情况下，使用轻量级锁产生的性能消耗； 在没有实际竞争的情况下，还能够针对部分场景继续优化。如果不仅仅没有实际竞争，自始至终，使用锁的线&gt; 程都只有一个，那么，维护轻量级锁都是浪费的。偏向锁的目标是，减少无竞争且只有一个线程使用锁的情况&gt; 下，使用轻量级锁产生的性能消耗。轻量级锁每次申请、释放锁都至少需要一次CAS，但偏向锁只有初始化时&gt; 需要一次CAS。 “偏向”的意思是，偏向锁假定将来只有第一个申请锁的线程会使用锁（不会有任何线程再来申请锁），因 此，只需要在Mark Word中CAS记录owner（本质上也是更新，但初始值为空），如果记录成功，则偏向锁获取成功，记录锁状态为偏向锁，以后当前线程等于owner就可以零成本的直接获得锁；否则，说明有其他线程竞争，膨胀为轻量级锁。 如果有其他线程申请锁，那么偏向锁很快就膨胀为轻量级锁。浪费了维持偏向锁的性能消耗 使用参数-XX:-UseBiasedLocking禁止偏向锁优化（默认打开）。 3.3. 轻量级锁 使用轻量级锁时，不需要申请互斥量，仅仅将Mark Word中的部分字节CAS更新指向线程栈中的Lock Record，如果更新成功，则轻量级锁获取成功。否则可以继续使用自旋锁获取或者升级为重量级锁; Mark Word是对象头的一部分；每个线程都拥有自己的线程栈（虚拟机栈），记录线程和函数调用的基本信息 轻量级锁的目标是减少无实际竞争的情况下，使用重量级锁产生的性能消耗; 如果锁竞争激烈，轻量级锁很快就将升级为重量级锁，那么维持轻量级锁的过程就成了浪费 3.4. 重量级锁 内置锁在Java中被抽象成监视器锁（monitor）。监视器锁直接对应底层操作系统的互斥量（mutex） 这种同步方式成本非常高，包括系统调用引起的内核态和用户态切换、线程阻塞造成的线程切换等 synchronized与ReentrantLock 两者都是可重入锁 synchronized依赖于JVM，ReentrantLock依赖于API ① synchronized是非公平锁; ② ReentrantLock可指定是公平锁或非公平锁 一个Lock对象可以创建多个Condition实例，线程对象可以注册在指定的Condition上，从而可以有选择性的进行通知 ReentrantLock比synchronized多一些高级功能 等待可中断ReentrantLock提供了一种可以中断等待锁的线程的机制。通过lock.lockInterruptibly()来实现。也就是使正在等待的线程可以放弃等待，改为处理其他事情; 可实现公平锁ReentrantLock可以指定是公平锁还是非公平锁。公平锁就是先等待的线程先获得锁，通过构造方法ReentrantLock(boolean fair)来实现; 可实现选择性通知 synchronized与volatile 并发编程的三个特性 ①原子性： 一个操作或者多次操作，要么都执行、要不都不执行。synchronized可以保证原子性②可见性： 当一个线程对共享变量进行了修改，其他线程可以马上看到最新的值。volatile可以保证可见性；③有序性： 代码在执行过程中，编译器会对字节码进行冲重排序优化，无法保证代码的执行顺序就是编写代码的顺序。volatile可以禁止指令重排； volatile是synchronized的轻量级实现 多线程访问volatile关键字不会阻塞，synchronized可能会阻塞 volatile能保证数据的可见性，不能保证原子性；synchronized两者都可以保证 volatile主要解决多线程之间数据的可见性问题；synchronized解决多线程之间数据的同步性问题 ThreadLocal 每个线程的专属变量，不会被其他线程访问到 ThreadLocal中有一个静态内部类ThreadLocalMap，可以理解为ThreadLocal的定制化HashMap实现。KEY为线程对象，Value为set进去的值 内存泄漏问题 ThreadLocalMap中的Key为ThreadLocal的弱引用，而Value是强引用。所以在ThreadLocal没有被外部强引用的时候，在垃圾回收时会把Key给回收掉，而Value却不会被回收。这样会出来Key为null的Entry。如果我们不做什么措施，Value就永远无法被回收，发生内存泄漏。ThreadLocal已经考虑了这种情况，在调用set()、get()和remove()方法时，会清理掉Key为null的Entry 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://persian.gitee.io/blog/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://persian.gitee.io/blog/tags/%E5%9F%BA%E7%A1%80/"},{"name":"多线程","slug":"多线程","permalink":"http://persian.gitee.io/blog/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"AOP","slug":"Java基础-AOP","date":"2021-03-05T13:02:06.545Z","updated":"2021-03-05T12:00:37.408Z","comments":false,"path":"article/20215905075902.html","link":"","permalink":"http://persian.gitee.io/blog/article/20215905075902.html","excerpt":"","text":"概念 面向切面编程，其作用是在不修改目标对象的情况下，进行逻辑扩展与增强。依赖代理模式（开闭原则的最好实践方式）核心技术是：反射。 原理 将复杂的需求分解出不同的方面（代码解耦），将抽离出来的逻辑，公共集中处理； 常见应用：权限控制，日志记录，持久化，事务等 在代理模式下，在不改变原程序的情况下，对目标对象进行逻辑增强、功能扩展等;综上：面向切面编程，是一种通过预编译方式和运行期动态代理的方式，在不修改目标代码的情况下，给程序动态增加功能的一种技术 已有框架 AspectJ SpringAOP AspectJ与SpringAOP的简单对比 区别： 织入时期不同： AspectJ – 静态织入 SpringAOP – 动态织入 目标对象不同: SpringAOP: 目标对象必须是SpringBean对象才可以； AspectJ: 可以是任何对象。 相关术语1. 增强处理 前置增强、后置增强、环绕增强、异常抛出增强、最终增强等。处理方式： 增强处理 ==&gt; 目标对象的方法 ==&gt; 增强处理 2. 切入点 SpringAOP通过一个表达式，去目标对象指定位置进行增强。可以把表达式认为一个查询条件或增加条件，表达式里面指定了目标对象的增强位置。 3. 连接点 SpringAOP通过切入点找到了目标对象要增强的代码位置，这个被切入的位置 – 连接点。 4. 切面 切面由一组增强处理和切入点共同组成。 5. 目标对象 目标对象即要被增强处理的目标类 – 也称委托类。 6. AOP代理 代理类即AOP代理，代理类里面包含了目标对象，以及对目标对象一些增强处理。– 代理类的执行逻辑，可参考代理模式。 7. 织入 织入就是指，将我们的增强处理，通过切入点编译到目标对象的连接点的过程。有静态织入和动态织入两种： 静态织入： 在编译时期就织入，即编译出来的class文件，字节码就已经被织入到了目标对象的连接点了。 – AspectJ 动态织入： 又分静动两种；– ApringAOP静表示织入过程只在第一次调用时执行；动表示根据代码动态运行的中间状态来决定如何操作，每次调用目标对象时都执行。 欢迎关注我的公众号，原创技术文章第一时间推送。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://persian.gitee.io/blog/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://persian.gitee.io/blog/tags/%E5%9F%BA%E7%A1%80/"},{"name":"AOP","slug":"AOP","permalink":"http://persian.gitee.io/blog/tags/AOP/"}]},{"title":"Hello world!","slug":"默认-hello-world","date":"2021-03-03T02:21:48.000Z","updated":"2021-03-04T14:13:54.769Z","comments":false,"path":"article/20213903103925.html","link":"","permalink":"http://persian.gitee.io/blog/article/20213903103925.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"初始化","slug":"初始化","permalink":"http://persian.gitee.io/blog/categories/%E5%88%9D%E5%A7%8B%E5%8C%96/"}],"tags":[{"name":"首页","slug":"首页","permalink":"http://persian.gitee.io/blog/tags/%E9%A6%96%E9%A1%B5/"}]}],"categories":[{"name":"运维","slug":"运维","permalink":"http://persian.gitee.io/blog/categories/%E8%BF%90%E7%BB%B4/"},{"name":"Java基础","slug":"Java基础","permalink":"http://persian.gitee.io/blog/categories/Java%E5%9F%BA%E7%A1%80/"},{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"设计原则","slug":"设计原则","permalink":"http://persian.gitee.io/blog/categories/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"},{"name":"初始化","slug":"初始化","permalink":"http://persian.gitee.io/blog/categories/%E5%88%9D%E5%A7%8B%E5%8C%96/"}],"tags":[{"name":"运维","slug":"运维","permalink":"http://persian.gitee.io/blog/tags/%E8%BF%90%E7%BB%B4/"},{"name":"centos7","slug":"centos7","permalink":"http://persian.gitee.io/blog/tags/centos7/"},{"name":"中间件安装","slug":"中间件安装","permalink":"http://persian.gitee.io/blog/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AE%89%E8%A3%85/"},{"name":"Java基础","slug":"Java基础","permalink":"http://persian.gitee.io/blog/tags/Java%E5%9F%BA%E7%A1%80/"},{"name":"IO","slug":"IO","permalink":"http://persian.gitee.io/blog/tags/IO/"},{"name":"java关键字","slug":"java关键字","permalink":"http://persian.gitee.io/blog/tags/java%E5%85%B3%E9%94%AE%E5%AD%97/"},{"name":"设计模式","slug":"设计模式","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"创建型模式","slug":"创建型模式","permalink":"http://persian.gitee.io/blog/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"结构型模式","permalink":"http://persian.gitee.io/blog/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"设计原则","slug":"设计原则","permalink":"http://persian.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"},{"name":"行为型模式","slug":"行为型模式","permalink":"http://persian.gitee.io/blog/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"spring","slug":"spring","permalink":"http://persian.gitee.io/blog/tags/spring/"},{"name":"bean","slug":"bean","permalink":"http://persian.gitee.io/blog/tags/bean/"},{"name":"基础","slug":"基础","permalink":"http://persian.gitee.io/blog/tags/%E5%9F%BA%E7%A1%80/"},{"name":"集合","slug":"集合","permalink":"http://persian.gitee.io/blog/tags/%E9%9B%86%E5%90%88/"},{"name":"反射","slug":"反射","permalink":"http://persian.gitee.io/blog/tags/%E5%8F%8D%E5%B0%84/"},{"name":"JVM","slug":"JVM","permalink":"http://persian.gitee.io/blog/tags/JVM/"},{"name":"对象创建","slug":"对象创建","permalink":"http://persian.gitee.io/blog/tags/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA/"},{"name":"多线程","slug":"多线程","permalink":"http://persian.gitee.io/blog/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"AOP","slug":"AOP","permalink":"http://persian.gitee.io/blog/tags/AOP/"},{"name":"首页","slug":"首页","permalink":"http://persian.gitee.io/blog/tags/%E9%A6%96%E9%A1%B5/"}]}